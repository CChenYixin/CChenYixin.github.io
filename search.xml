<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScrip 浅拷贝和深拷贝]]></title>
      <url>%2F2017%2F08%2F23%2Ftitle-%20JavaScript%20%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
      <content type="text"><![CDATA[摘要JavaScrip 中如何实现浅拷贝和深拷贝。 正文在 JavaScript 中对象、数组、函数等都属于引用类型，引用类型指指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象。当我们拷贝引用类型的变量时，复制的其实只是一个指针，拷贝后的对象和原来的对象指向同一块内存地址，改变其中一个，另一个也会发生变化。这种拷贝原对象的引用，即为浅拷贝。而深拷贝，会开辟一块新的内存地址，拷贝后的新对象与原对象互不影响。 浅拷贝把对象赋值给新的变量即为最简单的一种浅拷贝： 12345678910var o1 = &#123; name:'chen'&#125;;var o2 = o1;console.log(o1 === o2);// trueo2.name = 'yan';console.log(o1.name);// yan 在jQuery中我们可以调用 extend() 方法： 1jQuery.extend( target [, object1 ] [, objectN ] ) Object.assign() 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 语法：Object.assign (target目标对象, …sources) 返回值为目标对象 123var obj = &#123; a: 1 &#125;;var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125; 我们也可以自己写一个简单的浅拷贝: 12345678910111213141516function shallowCopy(oldObject)&#123; if (!oldObject || typeof oldObject != 'object' ) &#123; throw new Error('error arguments'); &#125; var newObject = oldObject === Array ? [] : &#123;&#125;; for(var keys in oldObject)&#123; if(oldObject.hasOwnProperty(keys))&#123; newObject[keys] = oldObject[keys]; &#125; return newObject;&#125; 深拷贝首先，我们依然可以使用jQuery中的exten()方法，只需要让deep参数变为 true：12jQuery.extend( [deep ], target, object1 [, objectN ] )// deep 如果是true，合并成为递归（又叫做深拷贝）。 利用JSON对象中的parse和stringify也可以实现深拷贝，JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象。1234function deepCopy(obj)&#123; var newObject = JSON.parse(JSON.stringify(obj)) return newObject;&#125; 我们也可以利用递归自己写一个深拷贝： 12345678910111213141516171819function deepCopy(oldObject) &#123; if(!oldObject || typeof oldObject !== 'object')&#123; throw new Error('error arguments', 'shallowClone'); &#125; var newObject = oldObject.constructor === Array ? [] : &#123;&#125;; for (var keys in oldObject) &#123; if (oldObject.hasOwnProperty(keys)) &#123; if(oldObject[keys] &amp;&amp; typeof oldObject[keys] === 'object')&#123; newObject[keys] = oldObject[keys].constructor === Array ? [] : &#123;&#125;; newObject[keys] = deepClone(oldObject[keys]); &#125;else&#123; newObject[keys] = oldObject[keys]; &#125; &#125; &#125; return newObject;&#125; 参考文章JavaScript中浅拷贝和深拷贝的实现JavaScript中的浅拷贝和深拷贝]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 如何实现重载]]></title>
      <url>%2F2017%2F08%2F22%2Ftitle-%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%20JavaScript%20%E9%87%8D%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[摘要文章主要讨论 JavaScript 中如何实现重载。 正文重载的含义重载指的是不同的函数使用相同的函数名，但函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。一个其他语言的重载例子：12345678910int sum(int num1, int num2)&#123; return num1 + num2;&#125;float sum(float num1, float num2)&#123; return num1 + num2;&#125;sum(1, 2);sum(1.5, 2.4); JavaScript 没有重载在 JavaScript 中函数是对象的一种，因此函数名实际上是一个指向函数对象的指针，不会与函数绑定，所以 JavaScript 中没有重载，同名函数会被覆盖重写。一个来自高程的例子：12345678function addSomeNumber(num)&#123; return num += 100;&#125;function addSomeNumber(num)&#123; return num += 200;&#125;var result = addSomeNumber(100) // 300 如何实现 JavaScript 重载switch语句通过对函数的 arguments对象的length值进行判断，来对不同的参数进行不同的操作 12345678910111213141516function overload(a,b)&#123; switch(arguments.length)&#123; case 0: // do basic code break; case 1: // do code with one break; case 2: // do code with two break; default: // do code with three break; &#125;&#125; 数组和对象也可以使用数据和对象的方式，通过数组的索引来对不同的参数进行不同的操作，原理和上面利用 arguments的length值类似。 123456789101112131415fooArr = [ function()&#123; // do basic code &#125;, function(a)&#123; // do code with one &#125;, function(a,b)&#123; // do code with two &#125;]function foo(a,b)&#123; return fooArr[arguments.length](a.b);&#125; 闭包来自 jQuery 之父 John Resig 的 JavaScript 函数重载方法。以下是一个完整示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function addMethod(object, name, fn)&#123; // 将前一个添加的方法保存在old中 var old = object[name]; // 重写object[name]方法 object[name] = function()&#123; // 假如传入的参数和预期的一致，直接调用 if (fn.length == arguments.length)&#123; return fn.apply(this, arguments); //否则，判断old是否为函数，如果是就直接调用 &#125; else if (typeof old == 'function')&#123; return old.apply(this, arguments); &#125; &#125;;&#125;/* 通过addMehod函数实现对find方法的重载 */// 不传参数时，返回所有namefunction find0()&#123; return this.names;&#125;// 传一个参数时，返回firstName匹配的namefunction find1(firstName)&#123; var result = []; for (var i = 0; i &lt; this.names.length; i++)&#123; if (this.names[i].indexOf(firstName) === 0)&#123; result.push(this.names[i]); &#125; &#125; return result;&#125;// 传两个参数时，返回firstName和lastName都匹配的namefunction find2(firstName, lastName)&#123; var result = []; for (var i = 0; i &lt; this.names.length; i++)&#123; if (this.names[i] === (firstName + " " + lastName))&#123; result.push(this.names[i]); &#125; &#125; return result;&#125;function Users()&#123; addMethod(Users.prototype, "find", find0); addMethod(Users.prototype, "find", find1); addMethod(Users.prototype, "find", find2);&#125;var users = new Users();users.names = ["John Resig", "John Russell", "Dean Tom"];console.log(users.find());// 输出[ 'John Resig', 'John Russell', 'Dean Tom' ]console.log(users.find("John"));// 输出[ 'John Resig', 'John Russell' ]console.log(users.find("John", "Resig"));// 输出[ 'John Resig' ]console.log(users.find("John", "E", "Resig")); 文章参考JavaScript函数重载How to overload functions in javascript?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器兼容的基本方法和思路]]></title>
      <url>%2F2017%2F08%2F10%2Ftitle-%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%9D%E8%B7%AF%2F</url>
      <content type="text"><![CDATA[摘要有关浏览器兼容的思路和一些常用的工具。 正文不同的浏览器有不同的标准不同的实现方式，同一个浏览器也有不同的版本不同的功能，版本越老的浏览器bug越多，在这样的差异背景下就产生了浏览器的兼容问：怎么样让同一份代码在所有的浏览器下都显示正常。 处理浏览器兼容的基本思路要不要实现从产品的角度。考虑网站的受众是什么，受众的浏览器是什么，我们可以通过查询浏览器市场份额查询所需要兼容的浏览器的份额，结合受众所使用浏览器的比例去考虑需要不要兼容。从成本的角度。某个效果的实际作用与需要实现其效果所花费的成本需要做个考量。 确认实现程度在确定需要做兼容后，再确认不同的浏览器需要实现到什么程度。 怎么实现在确定实现到什么程度时，我们同时需要考虑用什么方式去实现，是渐进增强还是优雅降级。 渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 最后我们再去考虑处理兼容问题的具体手段。 处理兼容的具体手段选对合适的框架 Bootstrap (&gt;=ie8)jQuery 1.~ (&gt;=ie6), jQuery 2.~ (&gt;=ie9)Vue.js (&gt;= ie9)React.js (&gt;= ie8)Angluar.js 1.2 (&gt;=ie8), Angluar.js 1.3 (&gt;=ie9) Angluar.js 2(&gt;=ie10) 条件注释条件注释 (conditional comment) 是于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码。 12345678910&lt;!--[if !IE]&gt;&lt;!--&gt; 除IE外都可识别 &lt;!--&lt;![endif]--&gt;&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt; CSS hack由于不同厂商的浏览器或不同版本的浏览器对CSS的解析不经相同，导致页面的渲染效果不一样，这时就需要对不同的浏览器做针对性的代码编写让不同的浏览器都能得到我们想要的效果。CSS hack大致有三种形式。 属性前缀法(即类内部Hack)。 12345“-″减号是IE6专有的hack“\9″ IE6/IE7/IE8/IE9/IE10都生效“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack“\9\0″ 只对IE9/IE10生效，是IE9/10的hackfirefox前述都不能认识 选择器前缀法。 12345678*html *前缀只对IE6生效*+html *+前缀只对IE7生效@media screen\9&#123;...&#125;只对IE6/7生效@media \0screen &#123;body &#123; background: red; &#125;&#125;只对IE8有效@media \0screen\,screen\9&#123;body &#123; background: blue; &#125;&#125;只对IE6/7/8有效@media screen\0 &#123;body &#123; background: green; &#125;&#125; 只对IE8/9/10有效@media screen and (min-width:0\0) &#123;body &#123; background: gray; &#125;&#125; 只对IE9/10有效@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;body &#123; background: orange; &#125;&#125; 只对IE10有效 IE条件注释法(即HTML条件注释Hack)。 12345&lt;!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries --&gt;&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 我们可以通过以下网站查询CSS属性的兼容和 Hack 的写法caniusebrowserhacks 常见的兼容工具html5shiv.jsHTML5已经成为主流，但是还是有很多人在使用IE6等版本，这些版本并不支持HTML5的标签，这时我们就可以使用html5shiv.js来让那些不认识HTML5标签的浏览器识别元素。html5shiv.js的基本原理是:使用createElement方法，这包含document.createElement和document.createDocumentFragment，对当前页面的HTML5元素进行动态的调整，并且为这些元素提供最基本的样式。而他的使用方法也很简单：1234567&lt;!--[if lt IE 9]&gt;&lt;script src=&quot;html5shiv.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;//or&lt;!--[if lt IE 9]&gt;&lt;script src=&quot;https://cdn.bootcss.com/html5shiv/r29/html5.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; js能力检测能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。采用这种方式不必顾及特定的浏览器如何如何，只要确定浏览器支持特定的能力，就可以给出解决方案。1234567891011121314//通过能力检测获取元素首先检测document对象是否有getElementById方法function getElement(id)&#123; if(document.getElementById)&#123; return document.getElementById(id);&#125;//然后检测是否有all对象else if(document.all)&#123; return document.all[id];&#125;//如果上述都没检测到则抛出错误else&#123; throw new Error(&apos;No way to retieve element&apos;);&#125;&#125; respond.jsRespond.js让不支持css3 Media Query的浏览器包括IE6-IE8等其他浏览器支持查询。12345&lt;!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries --&gt;&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; ModernizrModernizr让我们更加方便解决兼容性问题。 首先在head中引入。 1&lt;script src=&quot;https://cdn.bootcss.com/modernizr/2010.07.06dev/modernizr.min.js&quot;&gt;&lt;/script&gt; 向元素添加“no-js”的类 当Modernizr运行的时候，它会把这个“no-js”的类变为“js”来使你知道它已经运行。Modernizr并不仅仅只做这一件事情，它还会为 所有它检测过的特性添加class类，如果浏览器不支持某个特性，它就为该特性对应的类名加上“no-”的前缀。添加no-js class到html元素下，是告诉浏览器是否支持JavaScript，如果不支持就显示no-js，如果支持就把no-js删掉。 12345678910//在支持shadow阴影的浏览器显示shadow.boxshadow #MyContainer &#123; border: none; -webkit-box-shadow: #666 1px 1px 1px; -moz-box-shadow: #666 1px 1px 1px;&#125;//不支持的浏览器显示标准的边框.no-boxshadow #MyContainer &#123; border: 2px solid black;&#125; normalize.css and CSS reset最初的CSS reset的核心作用就是清零，强制所有标签的样式进行重置1234567:link,:visited &#123; text-decoration:none &#125;ul,ol &#123; list-style:none &#125;h1,h2,h3,h4,h5,h6,pre,code &#123; font-size:1em; &#125;ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,body,html,p,blockquote,fieldset,input&#123; margin:0; padding:0 &#125;a img,:link img,:visited img &#123; border:none &#125;address &#123; font-style:normal &#125; 后来Normalize.css取代了css reset，相比之下，Normalize.css保护有用的浏览器默认样式而不是完全去掉它们，但又为为大部分HTML元素提供一般性的样式病保证浏览器的一致性。 Normalize.css 只是一个很小的CSS文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS Reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。Normalize.css现在已经被用于Twitter Bootstrap、HTML5 Boilerplate、GOV.UK、Rdio、CSS Tricks 以及许许多多其他框架、工具和网站上。 1&lt;link href=&quot;https://cdn.bootcss.com/normalize/7.0.0/normalize.min.css&quot; rel=&quot;stylesheet&quot;&gt; 参考文章关于CSS Reset 那些事前端的瑞士军刀Modernizr.js客户端能力检测]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[「专注概念 VOL.2」定位与浮动]]></title>
      <url>%2F2017%2F08%2F06%2Ftitle-%E3%80%8C%E4%B8%93%E6%B3%A8%E6%A6%82%E5%BF%B5%20VOL.2%E3%80%8D%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[摘要文章第一部分关于浮动的概念、细节以及清楚浮动的方法，第二部分关于定位的概念、细节及相关的应用方式。 正文浮动在 CSS 中我们用float属性来定义元素的浮动。浮动并不完全是定位的一种方式，但是它也不是正常流的布局，当元素设置为浮动后，会产生一些有意思的特征，可能会影响到布局。 浮动的特征特征之一浮动的元素不在文档的普通流中，文档的普通流中的布局表现上就好比浮动框不存在一样。 普通流：浏览器根据元素在代码中出现的位置读取，再依照元素的盒子模型来呈现，具体表现为块级元素从上至下、 行内元素在每行中按从左至右的挨次排放元素。每个元素都会在HTML中占据一个位置，占用的大小和位置由盒模型来决定。 可以看到，当我们给第一个元素设置右浮动后，由于它从文档的普通流被删除了，它不会在占据空间，下面的块元素依次上移占据空白位置。它造成的一个常见的后果就是：其容器（父）元素将得不到脱离普通流的子元素高度；即当元素设置了浮动后，它的父元素的高度会塌陷。 特征之二设置了浮动的元素，会向左或右浮动（没有纵向浮动）直到碰到包含框或者另一个包含框的边框为止。假如某一行没有足够的空间可供浮动元素，这个浮动元素会自动跳到下一行，直到有足够的空间为止。 可以看到，第一个例子中当我们给元素设置右浮动后，浮动元素向右移动直到其包含框的右边缘，第二个例子我们把四个盒子都设置为右浮动，直到碰到另一个浮动元素的边框为止。这个规则的意义在于：使得相同级别的浮动元素很安全，完全不用担心一个浮动元素与另一个元素相互重叠。而利用 position 定位的时候很容易出现元素相互覆盖的情况。 特征之三设置了浮动的元素，会将元素的display属性设置为 block。宽度默认为auto，也就是说浮动非替换元素，假如不指明宽度，它的宽度会尽可能的小。注意图中的 width 变化以及 display 属性。原本是行内元素的 span 在设置了浮动后，display 属性变成了block： 浮动的影响对父元素的影响元素浮动后它脱离当前正常的文档流，所以它也无法撑开其父元素，造成父元素的塌陷。 对子元素的影响假如某个浮动元素没有设置高度和宽度，那么这个浮动元素的高度或宽度取决于子元素们的高度以及宽度的最大值（不管这个子元素浮动元素和非浮动元素都生效）。这与我们前面的特征三相一致。具体规则如图所示： 这个例子恰好提供了一个解决父元素塌陷的方法，我们可以将父元素和子元素都设置为浮动，这样就可以把浮动元素包含在父元素之内，（实不实用另说）。 对兄弟元素的影响1、浮动兄弟元素的影响 当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面，当空间不够时会被挤下，与特征二相吻合。 2、非浮动兄弟元素的影响 如果如果兄弟元素为内联元素，则元素会环绕浮动元素排列。如果兄弟元素为块级元素，该元素占据它的位置，并且元素会处在浮动元素的下层（并且无法通过z-index属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素。 清楚浮动的方法只介绍两种： 123456789101112// 伪元素清除浮动法.float::after &#123; content: &quot;&quot;; display: table; clear: both;&#125;//BFC清除浮动法.cleanfix &#123; overflow: hidden; zoom: 1;&#125;//以上两种方法都是给浮动元素的父容器使用 定位相对定位相对定位重点在于相对。使用相对定位的元素会导致元素相对它的起点进行移动，但是普通流中仍然保持着原有的默认空间，并没有脱离普通流，只是视觉上的偏移。移动元素会导致视觉上覆盖其它框。 绝对定位绝对定位相对复杂。使用绝对定位的元素会相对于 最近的已定位祖先元素 去移动，如果没有已定位的祖先元素，那么它的位置相对于最初的包含块。与相对定位不同，设置为绝对定位的元素框从文档流完全删除，就好像该元素原来不存在一样，元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 绝对定位需要注意的细节： 应用了position: absolute / relative之后，会覆盖其他非定位元素，我们可以z-index 属性来改变他们的上面层级； 应用了position: absolute / relative之后，尽量使用自带的 top、bottom、left、right来定位，不要使用 margin； 定位与浮动尽量不要定位与浮动混合使用，因为这样的方式出了问题很难去调式，不过还是有几个规则可以借用。 1、 规则一：相对定位和浮动可以共用，先浮动再相对定位 可以看到图中盒子1同时设定了浮动和相对定位，首先它浮动到右边的位置，再相对它原来的位置向左偏移。 2、 规则二：绝对定位和浮动不可以共用，浮动会失去效果 可以看到图中盒子1同时设定了浮动和绝对定位，我们设置它左浮动，但没有效果，它相对于它的最近定位的祖先元素定位（例子中为body）。 参考文章CSS权威指南w3school文档对CSS中的Position、Float属性的一些深入探讨]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML 表单需要注意的细节]]></title>
      <url>%2F2017%2F08%2F03%2Ftitle-%20HTML%20%E8%A1%A8%E5%8D%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82%2F</url>
      <content type="text"><![CDATA[摘要关于 HTML 表单的一些细节和需要注意的点。 正文name 属性input 标签的 name 属性name 属性规定 input 元素的名称。只有设置了 name 属性的表单元素才能在提交表单时传递它们的值。 可以说这是一个必须添加的属性，来用于对提交到服务器后的表单数据进行标识。 123/*radio 使用 name 属性来分组的，所有 name属性相同的 radio 使用时其中只有一个会被选中。*/&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot;&gt; form 标签的 name 属性name 属性规定表单的名称。 button 标签的 name 属性name 属性为按钮规定名称。不同的 button 元素可以共享相同的名称。这就允许我们标记带有相同名称的若干按钮，以便在表单中使用时能够提交不同的值。 value 属性value 属性为 input 元素设定值。这个相对 name比较复杂，对于不同的输入类型，value 属性的用法也不一样： type=”button”, “reset”, “submit” - 定义按钮上的显示的文本 一般来说是必要的。 type=”text”, “password”, “hidden” - 定义输入字段的初始值 type=”checkbox”, “radio”, “image” - 定义与输入相关联的值 value 属性对于 &lt;input type=&quot;checkbox&quot;&gt; 和 &lt;input type=&quot;radio&quot;&gt; 是必需的。 form 标签中需要注意的标签 action属性的值是一个URL，规定当提交表单时向何处发送表单数据。 autocomplete属性规定是否启用表单的自动完成功能，这是一个HTML5新属性。当用户开始输入时，浏览器会根据过去的值进行预测，并显示供用户选择。 1&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; autocomplete=&quot;on&quot;&gt;&lt;/form&gt; method属性规定表单请求的方式 HTTP定义了客户端与服务器之间的通信方式，POST和GET是最基本的两种。GET是向服务器发索取数据的一种请求，POST是向服务器提交数据的一种请求。 形式不同：GET方法会把请求的数据附在URL链接之后，用 ? 来连接URL链接和传输的数据，参数之间通过 &amp; 相连。POST方法把提交的数据放到HTTP的包体中； 对数据的限制不同：GET方法通过URL链接提交所以与URL链接的长度有关，由于浏览器的限制，数据传输体积较小。POST方法理论上没有限制，与服务器的处理能力有关。 安全性不同。GET请求账号密码将明文出现在URL上，由于缓存或者历史纪录等原因，容易被他人窃取。POST由于无法直接读取相对安全一些。 表单提交 input[type=submit]这是我们最常用的提交方式，当我们给input设置[type=submit]时，输入控件会变成一个按钮，显示的文字为其value值。前面提到当我们给input添加 name 属性后 name 也会被提交。这种的方式的缺陷是：作为一个自闭和的标签，它的样式难以定制、不可作为其他标签的容器，所以建议不要用作表单提交按钮。 input[type=button]仅仅去定义一个按钮，不会引发表单提交。 button[type=submit]同样是定义按钮，但更加强大，我们可以放置内容，比如文本或图像。这是该元素与使用 input 元素创建的按钮之间的不同之处。 button标签之间的所有内容都是按钮的内容，其中包括任何可接受的正文内容，比如文本或多媒体内容。例如，我们可以在按钮中包括一个图像和相关的文本，用它们在按钮中创建一个吸引人的标记图像。 因此由于button的可定制性，我们推荐用button作为交互用的按钮，来提交表单。需要注意的是 button居然也可以设置name和value并且value会被作为表单数据提交给服务器。 文章参考w3school文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[「网页运行原理 VOL.1」域名解析]]></title>
      <url>%2F2017%2F07%2F26%2Ftitle-%20%E3%80%8C%E7%BD%91%E9%A1%B5%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%20VOL.1%E3%80%8D%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[摘要主要记述DNS的运行原理以及DNS的解析过程。 正文网页运行流程当我们在浏览器输入一个URL地址时: 浏览器在域名系统服务器上找出存放网页的服务器的真实地址。 浏览器发送 HTTP 请求信息到服务器拷贝一份网页到客户端。这条消息，包括其他所有在客户端和服务器之间传递的数据都是通过互联网TCP/IP协议传输的。 服务器同意客户端的请求后，会返回一个“200 OK”信息，意味着你可以查看这个网页，然后开始将网页的文件以数据包的形式传输到浏览器。 浏览器将数据包聚集成完整的网页，然后呈现给你。 为什么需要DNS解析当我们在输入URL访问网页，我们输入的域名比如www.google.com并不是真正的网址。在互联网中网路之间的通讯都是基于TCP/IP协议，而TCP/IP协议基于IP地址，所以真正的网址实际上是一串难以记忆的数字IP地址，比如63.245.217.105。但是我们并不能记住那么多的IP地址，所以我们访问网站时更多的是在地址栏中输入域名。 但是对浏览器来说，并不知道域名是个什么东西，这时就需要DNS来把我们输入的域名翻译成浏览器可识别的相应的IP地址，然后再去向服务器发送请求调用网页。一言蔽之：DNS主要作用就是将主机域名转换为ip地址。 网域名称系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。 域名解析的相关概念DNS 的核心是一个分层系统。在这个系统的顶部是“根服务器”，这些服务器处理有关顶级域名的信息请求。根服务器只有13个IP地址，但是我们可以在全球设立这些IP的镜像，当我们对某个根服务器发出请求时，请求会被路由到该根服务器离你最近的镜像服务器。根服务器下面一层是TLD（顶级域名）服务器，当我们想根服务器请求某个域名比如www.google.com，根服务器并不能找到与www.google.com匹配的记录，但它会找到.com的记录，并返回给请求者，再由请求者向负责顶级域名的服务器发送新的请求，同样的我们的顶级域名服务器并不能找到与www.google.com匹配的记录，但它可以找到google.com的记录，并返回给请求者。再向负责域名级别的名称服务器继续发送请求，此时名称服务器检查其区域文件，并发现它有与 “www.google.com” 相关联的区域文件。在此文件的内部，有一个 “www” 主机的记录。此记录说明此主机所在的 IP 地址，并向请求者返回最终答案。 域名解析的流程具体的DNS解析流程如下： 浏览器缓存 – 当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）； 系统缓存 - 从 Hosts 文件查找是否有该域名和对应 IP。当我们访问某个域名时，操作系统会首先检查本地的host文件是否有这个网址的映射地址，如果有的话就调用完成域名解析。 路由器缓存 – 当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存； ISP（互联网服务提供商） DNS 缓存 – 当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找； 如果都没有找到，则向根域名服务器查找域名对应 IP，根服务器不知道实际托管域名的位置。然而，他们会将请求引导到处理特定请求的顶级域名的名称服务器。顶级域名服务器收到请求后查看区域文件记录，它会负责找到域名级别名称服务器的IP地址，名称服务器检查其区域文件，查找相关的IP地址，并返回最终的IP地址。 摘要什么是 DNSDNS 如何工作域名解析篇网络是如何工作的DNS解析的过程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git 命令中的参数问题]]></title>
      <url>%2F2017%2F07%2F23%2Ftitle-%20Git%20%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[摘要有关git reset命令的参数以及git commit -a的解释 正文Git reset 命令的参数git reset是 Git 最常用的命令之一,主要用于版本的回退重置.它的一般写法为:1$ git reset 参数[--soft | --mixed | --hard] 版本号[&lt;commit id&gt;] 使用--hard参数在工作区新建文件reset.html,然后提交到本地的仓库,此时本地的工作区和版本库都有了这个文件,如图所示: 接下来我们运行命令git reset --hard HEAD^,关于 HEAD 参考上篇文章Git 基本原理和常用命令.这个命令会让我们的版本回到上一个版本.如图所示: 此时我们清晰的看到不仅仅版本库中的reset.html没有了,在工作区中我们新建的reset.html也没有了.也就是说当我们加了参数--hard时会: 替换指针 HEAD 的指向,例子中我们指向上一个版本. 替换暂存区,当我们用git status查看状态时会提示working tree clean. 替换工作区,替换后的工作区和被替换后的暂存区是一样的,也和HEAD指针的指向是一样的. 这意味着--hard是一个比较危险的参数,它不仅仅重置我们的版本库暂存区,连工作区的内容也会受到影响. 使用-soft参数重复类似上面的步骤,只是这次我们吧参数换为--soft,我们可以清晰看到区别: 版本库提交的soft.html已经重置到上个版本没有了,但是在工作区却保留着soft.html,也就是说当我们加了参数--soft时会: 替换指针 HEAD 的指向,例子中我们指向上一个版本. 但是工作区和暂存区没有发生改变. 这意味着--soft仅仅回退到上个版本(在这个例子中),而不改变工作区和缓存区,也意味着我们对文件的修改不满意了,可以在原有的工作区文件上继续更改.相对来说是一个比较安全的指令. Git commit 中的参数a commit-a Tell the command to automatically stage files that have been modified and deleted, but new files you have not told git about are not affected. 先说结论: 尽量的不要用git commit -a这种形式来提交文件 尽量使用git add和git commit的分次添加提交 在修改文件,注意是在修改文件后,为什么是修改呢?这意味着这个文件已经存在在版本库中,在这个基础上我们修改文件后使用git commit -am,此时我们不需要使用git add.直接使用这个命令就可以直接提交到版本库.换句话说, 一般来说在修改文件后，需要使用git add把文件加入暂存区，这样git commit时才能把已经修改的信息加入版本库，而使用git commit -a可以不用再git add。再次注意是 在修改文件后. 我们来模拟这种情况,首先新建test.html并按正常步骤提交,现在它已经在版本库中:现在我们修改test.html,并用命令git commit -am提交来看看: ok,好像没有什么问题.现在我们新建一个文件直接用git commit -a来试试: 提示: Untracked files: test2.htmlnothing added to commit but untracked files present untracted files 未追踪的文件不会被提交到仓库区,也就是说新建的文件没有被追踪所以不会被提交.为什么修改的文件可以提交而新建的文件不能被提交呢?因为修改的文件比如上面的例子我们已经git add过,仓库会追踪文件的变动,并可以被提交.而新建的文件只是在工作区没有被追踪是不可以被提交的. 简单来说:git commit -am &quot;say something&quot;这个命令会让 当前在暂存区里面 的文件修改保存并且 commit,而新建的文件是untracted files状态,没有在暂存区里被 Git 仓库所标记追踪,因此是不可以用这种方式提交的. 再来看这个命令的解释就一目了然了: commit-a Tell the command to automatically stage files that have been modified and deleted, but new files you have not told git about are not affected. 新建的文件没有加入暂存区,没有加入暂存区没有被追踪,没有追踪的文件不会被提交到仓库区.所以,不推荐使用git commit -a,还是推荐先git add再git commit. 参考文章Git git commit -a命令困惑版本回退]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git 基本原理和常用命令]]></title>
      <url>%2F2017%2F07%2F22%2Ftitle-%20Git%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[摘要介绍 Git 的基本原理以及一些常用的操作命令。 Git基本原理Git文件改动提交的基本原理Git 是一种分布式的版本控制工具。它的控制系统由两个部分组成:工作区（Working Directory） 和 版本库（Repository）。 Git 的工作流程如上图所示，首先是我们日常的 工作区，它实际持有文件。其次是 版本库，即工作区隐藏文件.git，记录我们文件的变动和提交。在版本库中，最重要的内容是 缓存区*(Index/stage)，它就像一个缓存区域，用来临时保存你的文件变动。最后是 HEAD，它一般指向我们最后一次提交的结果。 也就是说。当我们往 Git 版本库中添加文件的时候，会分成两个部分来执行，首先用git add把文件添加到缓存区，然后再用git commit提交更改，即把缓存区的文件提交到当前的分支上去。 Git版本控制的基本原理Git会记录我们的每一次提交，这样我们对文件的改动就会像时间线一样被 Git 记录下来。而 HEAD 就指向这条时间线最后一次提交的结果。因此比如说我们要回退到上一个版本就可以用命令git reset --hard HEAD^，但如果我们要回退到某个版本，我们就必须要只要那个版本的版本号(commit id)， Git提供了命令git log来供我们查找历史纪录。 这样我们通过git log来查询我们需要回退的版本号，然后利用命令git reset --hard 版本号来回退到我们需要的版本。 Git分支管理的基本原理上面指出 HEAD 一般指向我们的最后次的结果。那么HEAD本身是什么呢?通俗的来说，HEAD是一个指针，一般来说指向分支的最顶端，也就是我们最后一次提交的结果，但实际上它可以指向任意一个节点， Git就是利用它来追踪位置。当我们初始化一个 Git 仓库时，默认指向我们的主分支master。假如我们创建新的分支时，我们就可以通过命令git checkout 分支名切换到新的分支，这时HEAD指向我们新建的分支，这时对工作区的修改和提交就是针对我们新建的这个分支了，而原来master不会变化。当我们在新建的分支上修改满意后，再切回到主分支，然后用命令git merge把刚刚修改的结果合并到主分支上。这样就完成了一次分支的操作。 常用 Git 命令文件改动提交相关1234567891011121314151617# 添加指定文件或目录到缓存区$ git add file/dir# 添加加当前目录的所有文件到暂存区$ git add . # 提交缓存区到仓库区$ git commit -m &quot;代码提交信息&quot;# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 显示有变更的文件$ git status# 提交到远程的仓库git push origin master 版本控制相关123456789101112# 显示当前分支的版本历史$ git log$ git log --pretty=oneline# 显示暂存区和工作区的差异$ git diff# 显示当前分支的最近几次提交$ git reflog# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard &quot;版本号&quot; 分支管理相关1234567891011121314151617181920# 列出所有本地分支$ git branch# 新建一个分支，并切换到该分支$ git checkout -b &quot;分支名&quot;# 切换到指定分支，并更新工作区$ git checkout &quot;分支名&quot;# 合并指定分支到当前分支$ git merge &quot;指定分支&quot;# 删除分支$ git branch -d &quot;分支名&quot;# 提交到远程的仓库$ git push origin &quot;分支名&quot;# 要更新你的本地仓库至最新改动$ git pull 其他12# 显示当前的Git配置$ git config --list 参考文章git - 简明指南常用 Git 命令清单git教程 -廖雪峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux 命令行和 Vim 使用的基础操作]]></title>
      <url>%2F2017%2F07%2F17%2Ftitle-%20Linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8C%20vim%20%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[摘要一些 linux 命令行和 vim 编辑器的基础操作 正文linux命令行基础操作与 Windows 中磁盘分区的概念不同, Linux 中并没有类似C盘这样的说法,而是都以文件名来表示,所有的文件和目录都挂载在根目录「/」下面123//linux命令行$ 命令 -选项缩写 --选项 参数结果 目录相关操作1234567//创建目录mkdir 目录名mkdir -p 目录路径//其中 . 代表当前目录 .. 代表上层目录 ~ 代表当前登录用户的宿主目录 - 代表前一目录,既进入当前目录之前操作的目录cd 进入目录pwd 显示当前目录 文件相关操作1234567891011121314//创建文件touch 文件名//删除文件rm 文件rm -r 目录名rm -i 删除文件时是否确认//复制文件cp 源文件名 目标路径cp -r 目录 目录//移动文件mv 要移动的文件 目标路径 列出文件清单操作1234ls 文件名或目录名ls -l 列出详细信息ls -a 列出所有文件包括隐藏文件ls -R 列出所有内容包括子目录 vim 编辑器基础操作12345678910//进入vim编辑器vim//进入教程vimtutor//插入文本i//保存并推出:wq//直接退出:q 参考文章linux基本命令]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[「专注概念 VOL.1」JavaScript 语法]]></title>
      <url>%2F2017%2F03%2F05%2Ftitle-%20%E3%80%8C%E4%B8%93%E6%B3%A8%E6%A6%82%E5%BF%B5%20VOL.1%E3%80%8DJavaScript%20%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[摘要 “Focus on concepts, not syntax”“把注意力放在对概念的理解，而不是语法上” 这是在某个网站上看到的一句话，也这是记述这个系列的笔记的原因。 正文基本语法 变量是对“值”的引用，使用变量等同于引用一个值，每一个变量都有一个变量名，变量可以用来保存任何值。在 JavaScript 中没有块作用域，只存在全局作用域和函数作用域。当在函数中使用var定义一个变量，那么这个变量就是局部变量，在函数退出后就会被销毁。 12345function test()&#123; var message = &apos;hi&apos;;&#125;test();alert(message);//错误 在同一个作用域中，一个变量只能保存一个值，如果使用var第二次生命且赋值，会覆盖掉前面的值。 JavaScript引擎的工作方式是，首先解析代码，获取所有被声明的变量，然后在一行行的执行，所以所有的变量声明语句，都会被提到代码的头部，这就叫做“变量提升”。12console.log(a);var a = 1;//undefined JavaScript 是一行行的运行代码，按理第一行代码后应该抛出错误，但是实际上由于变量提升的原因，浏览器并不会报错，而会显示undefined，表示 a 已经声明但未赋值。 标识符就是用来识别一个具体对象的名称，变量名就是一种标识符。 我们可以使用switch语句来代替多个if…else的情况，基本结构如下：12345678910switch ( expression)&#123; case value: statement break; case value: statement break; case value: statement break; ... default:statement&#125; 语句中的每一个情形 case ，其基本含义如果表达式等于语句中的这个值 value，则执行后面的语句 statement。break 表示提出switch结构，而default表示，当每一种case都不符合时，执行其后面的语句。 三元运算符，假如语句中condition为true则，返回expr1的值，负责返回expr2的值。(condition) ? expr1 : expr2 javascript中可以再代码中添加标签，以便将来使用。通常用来和 break 和 continue 配合使用来跳出循环。break会立即退出循环强制执行循环后面的语句，而continue虽然也是立即退出循环，但会重循环的顶层继续执行。 数据类型 JavaScript（ES5） 中有六种数据类型。 数值（number）：整数和小数（比如1和3.14）字符串（string）：字符组成的文本（比如”Hello World”）布尔值（boolean）：true（真）和false（假）两个特定值undefined：表示“未定义”或不存在，即此处目前没有任何值null：表示空缺，即此处应该有一个值，但目前为空对象（object）：各种值组成的集合 在这其中，数值、字符串、布尔值被称为原始类型的值，undefined 和 null 被看作是两个特殊值。而对象是JavaScript中比较复杂的值。广义的对象包括数组、函数、甚至连原始类型的值都可以包装为对象来使用。 我们通常用以下三种方法来确定一个值的类型。 typeof运算符instance of运算符Object.prototype.tostring()方法 当我们调用typeof运算符时候，数值、字符串、布尔值分别返回number string boolean ,函数返回function ,undefined 返回undefined,其他的诸如对象，数组，null都返回object。假如我们要具体判断是否是数组或对象，我们可以使用instance of。 如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefinednullfalse0NaN“”或’’（空字符串） 数值 NaN是JavaScript的一种特殊值，表示非数字（NOT A NUMBER）,主要出现在将字符串解析成数字出错的场合。NaN不等于任何值，包括它本身。我们可以使用isNaN来判断一个值是否是NaN，但需要注意的在使用前，最好先判断该值是不是数值，因为 如果传入其他值，会被先转成数值。 12345678910isNaN([123]) // false//goodfunction myIsNaN(value) &#123; return typeof value === &apos;number&apos; &amp;&amp; isNaN(value);&#125;//orfunction myIsNaN(value) &#123; return value !== value;//NaN不等于任何值&#125; 与数值有关的全局方法parseInt()和parseFloat()。parseInt方法用于将字符串转换为整数。假如字符串的头部有空格，会被自动去除，假如要转换的不是字符串，会先转换为字符串在转换。字符串转换为整数的时候是 一个一个转换，如果遇到不能转换为数字的字符，就不再进行返回已经转好的部分，换句话说只转换字符串头部可以转换的部分。（正负号除外。）该方法接受参数，表示被转换值的进制，默认为十进制转十进制。 parseFloat方法用于将一个字符串转为浮点数。 12parseInt(1.23) // 1parseFloat(1.23) // 1.23 字符串 字符串可以被视为字符数组，从来调用[]来返回某个位置的字符。但是字符串是只读的，无法运用数组的方法来改变字符串。字符串length属性返回字符串的长度。 charAt()方法可返回指定位置的字符。charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。我们常常用到来验证表单输入12345678910111213141516171819202122232425262728293031323334353637var inputText = document.getElementsByClassName(&apos;inputtext&apos;)[0];var tip = document.getElementById(&apos;tip&apos;);var button = document.getElementsByTagName(&apos;input&apos;)[1];//字符长度var strLength = function(str)&#123; var len = 0; for(var i=0;i&lt;str.length;i++)&#123; charCode = str.charCodeAt(i); if(charCode &gt;= 0 &amp;&amp; charCode &lt;= 128)&#123; len +=1; &#125;else&#123; len +=2; &#125; &#125; return len;&#125;;//验证function validate()&#123; var content = inputText.value.trim(); if(strLength(content) === 0)&#123; tip.innerHTML = &apos;名称不能为空！&apos;; tip.className = &apos;on&apos;; inputText.className += &apos; warn&apos;; &#125;else if( strLength(content)&gt;=4 &amp;&amp; strLength(content)&lt;=16 )&#123; tip.innerHTML = &apos;格式正确&apos;; &#125;else&#123; tip.innerHTML =&apos;字符数应为4-16位&apos;; tip.className = &apos;on&apos;; inputText.className=&apos;warn&apos;; &#125;&#125;//绑定button.onclick =function()&#123; validate();&#125;; 对象 对象，就是一种无序的数据集合，由若干和“键值对”构成，所有键名都是字符串。我们可以用下面三种方法来生成对象。 var object1 = {};var object2 = new Object();var object3 = Object.create(Object.prototype); 对象的键名又称为属性，它的键值可以是任何值，如果一个属性的值为函数，那么这个属性称为方法，可以像函数一样调用。 不同的变量名指向同一个对象，那么它们都是这个对象的引用，指向同一个内存地址，这意味着修改其中一个变量会影响到其他所有的变量，对于原始类型的值来说，是传值引用。因为是值的拷贝，所以当某个变量的值发生变化，另外一个不会受到影响，因为它们并不是指向同一个内存地址。 我们用in运算符来检查对象是否包含某个属性，用for..in来遍历对象的全部属性，因为可以遍历继承的属性，假如要只遍历对象本身的属性，需要用到hasOwnPrototype 12345for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125; 数组 数组，按次序排列的一组值。数组本身一种特殊的对象，比如in和for...in都可以被数组使用。我们也可以使用对象的方法Object.keys来返回数组的键名： 1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];Object.keys(arr)// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] 数组的length属性返回数组的成员数量。注意length是一个可写的属性，这意味着如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。将数组清空的一个有效方法，就是将length属性设为0。 函数(另写文章总结) 语法错误 了解基本的错误类型： SyntaxError是解析代码时发生的语法错误ReferenceError是引用一个不存在的变量时发生的错误RangeError是当一个值超出有效范围时发生的错误TypeError是变量或参数不是预期类型时发生的错误 参考文章JavaScript 标准参考教程JavaScript高级程序设计]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript 和树]]></title>
      <url>%2F2017%2F02%2F27%2Ftitle-%20JavaScript%20%E5%92%8C%20%E6%A0%91%2F</url>
      <content type="text"><![CDATA[摘要百度 IFE 任务22到24的相关笔记，主要关于树的概念，遍历。 正文树与二叉树树形结构是一种重要的数据结构，我们常常用树来组织信息，描述遍历的行为过程。首先是树的概念：树是一个有 n 个结点的有限集。在任意一个非空的树中有且仅有一个特定的结点称为根，当结点大于1时，各个结点可以分为互不相交的有限集合，每个集合本身又是一棵树，称为根的子树。树是具有层次结构的，我们把根结点所在层称为第一层，其孩子为第二层，以此类推，树中结点的最大层次称为树的深度。 而二叉树是一种特殊的树。它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分（其次序不能任意颠倒。）二叉树的性质：1.在二叉树的第i层上至多有2的i-1次方个结点(i&gt;=1)。2.深度为k的二叉树至多有2的k次方-1个结点，(k&gt;=1)。3.对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1; 二叉树的遍历二叉树的遍历主要分三种： 先（根）序遍历：根左右 中（根）序遍历：左根右 后（根）序遍历：左右根 123456789101112131415161718192021222324//前序function preOrderRec(node)&#123; if(node)&#123; divList.push(node); preOrderRec(node.firstElementChild); preOrderRec(node.lastElementChild); &#125;&#125;//中序function inOrderRec(node)&#123; if(node)&#123; inOrderRec(node.firstElementChild); divList.push(node); inOrderRec(node.lastElementChild); &#125;&#125;//后序function postOrderRec(node)&#123; if(node)&#123; postOrderRec(node.firstElementChild); postOrderRec(node.lastElementChild); divList.push(node); &#125;&#125; 多叉树遍历深度优先遍历 深度优先遍历，从初始访问结点出发，我们知道初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点。总结起来可以这样说：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。 具体算法表述如下： 访问初始结点v，并标记结点v为已访问。 查找结点v的第一个邻接结点w。 若w存在，则继续执行4，否则算法结束。 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。 查找结点v的w邻接结点的下一个邻接结点，转到步骤3。 12345678function traverseDF(node,nodeList)&#123; if(node)&#123; nodeList.push(node); for(var i= 0;i&lt;node.children.length;i++)&#123; traverseDF(node.children[i],nodeList); &#125; &#125;&#125; 广度优先遍历 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点。 具体算法表述如下： 访问初始结点v并标记结点v为已访问。 结点v入队列 当队列非空时，继续执行，否则算法结束。 出队列，取得队头结点u。 查找结点u的第一个邻接结点w。 若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤： 1). 若结点w尚未被访问，则访问结点w并标记为已访问。2). 结点w入队列3). 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。 12345678910function traverseBF(node, nodeList) &#123; if (node) &#123; nodeList.push(node); //nextElementSibling 返回当前元素在其父元素的子元素节点中的后一个元素节点,如果该元素已经是最后一个元素节点,则返回null,该属性是只读的. traverseBF(node.nextElementSibling, nodeList);//回传 node的下一个元素对象 node = nodeList[BFindex++]; //ParentNode.firstElement 是一个只读属性，返回当前元素的第一个子元素节点，如果没有子元素节点，则返回null。 traverseBF(node.firstElementChild, nodeList); &#125;&#125; 总结这部分的IFE任务大部分都参考了别人的代码，感觉这方面有待加强，感觉除过 Javascript 的相关内容，如果对计算机的一些基本的基础的概念有个良好的把握的话对这些会更有帮助，理解起来可能更好理解。 参考文章图的理解：深度优先和广度优先遍历js数据结构和算法（三）二叉树javascript实现数据结构： 树和二叉树,二叉树的遍历和基本操作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IFE task 13-21 笔记]]></title>
      <url>%2F2017%2F02%2F26%2Ftitle-%20IFE%20task%2013-21%20%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[摘要文章为百度前端技术学院2016年任务 13-21 的笔记，大概是 Jvascript 基础部分。总结了一些收获，记述了其中遇到的问题和困难，以及一点感想。因为内容稍微多一点，文章的结构就按照各个任务来划分。 正文任务 13假设我们要获取某个输入域中的数值，我们可能需要value属性和’parseInt()’。首先，我们需要注意在HTML中value是input的设定值，对于不同的输入类型，value属性的用法也有区别： type=”button”, “reset”, “submit” - 定义按钮上的显示的文本type=”text”, “password”, “hidden” - 定义输入字段的初始值type=”checkbox”, “radio”, “image” - 定义与输入相关联的值 正如任务13中一样我们要获取’id=”aqi-input”‘的value值，我们可以用：1var inputValue = document.getElementById(&apos;aqi-input&apos;).value; 这样我们就获得了input中的输入值，当然此时获得的是字符串。我们在用parseInt()来将给定的字符串解析成整数(如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。另外可以给其传入第二个参数，用于指定转换的基数)。1var num = parseInt(inputValue); 在实际应用过程中我们可能需要判断得到的值。这时我们可以用isNaN来判断是否是一个NaN值，具体操作中我们往往需要在前面加个!(非)来表示判断该值是否符合条件：if(!isNaN(num))，假如num是一个数值的话。 任务14对数据的操作是个人认为学习的难点，数据可能保存在一个数组中或对象里。所以对数组进行的操作是也需要重点的关注。比如在任务中我们需要对数组进行重排序。就需要用到sort()方法，’sort()’方法在适当的位置对数组的元素进行排序，并返回数组，默认的排序可能会按照字符串的Unicode，所以排序的顺序不是很稳定，方法接受一个参数，为某种顺序进行排列的函数。 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 所以我们可以这个来进行排序：12aqiData.sort(function(a,b)&#123; return b[1] - a[1]; 按照上面的写法，aqiData会按照自大到小的顺序来排列。除了sort()还有’reverse()’的方法反转数组来进行重排序。除了排序，有些时候我们还要对数组进行迭代，找出合适或者不合适的对象比如： filter()方法。filter方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。 1234[1, 2, 3, 4, 5].filter(function (elem) &#123; return (elem &gt; 3);&#125;)// [4, 5] map()方法。map方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。 1234567var numbers = [1, 2, 3];numbers.map(function (n) &#123; return n + 1;&#125;);// [2, 3, 4]numbers// [1, 2, 3] every()方法：对数组每一项运行给定函数，如果每一项返回true，则返回true some()方法：对数组每一项运行给定函数，如果任意一项返回true，则返回true forEach()方法：对数组每一项运行给定函数，无返回值，相当于遍历数组。除过数组的操作，有关document节点的操作也很重要。document是文档的根节点，只要浏览器开始载入HTML文档，这个节点对象就存在了，可以直接调用。最常用比如查找节点的方法以及生成节点的方法。 查找节点 document.querySelector()，可以接受一个CSS选择器作为参数，返回匹配改选择器的元素节点，如果有多个满足条件的元素节点，则返回第一个匹配的节点。 document.getElementsByTagName()，返回所有指定的HTML标签的元素，返回值是一个元素的集合。 document.getElementsByClassName(),返回所有CLASS符合指定条件的元素，返回值一个元素的集合。 document.getElementsByName()，选择拥有name属性的HTML元素. document.getElementById(),返回匹配指定id属性的元素节点。 生成节点 document.createElement()，用来生成网页元素节点。 document.createTextNode()，方法用来生成文本节点，参数为所要生成的文本节点的内容。 除了作为根节点的document，DOM 文本对象模型中的每个组成单位都可以看作成为一个节点(node),所有节点对象都是浏览器内置的Node对象的实例，继承了Node属性和方法。比如： 节点的相关属性 Node.parentNode，属性返回当前节点的父节点。 Node.childNodes，返回一个NodeList集合，成员包括当前节点的所有子节点。 Node.firstChild，Node.lastChild，firstChild属性返回当前节点的第一个子节点，lastChild属性返回当前节点的最后一个子节点。 节点对象的方法 Node.appendChild()方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。 12var p = document.createElement(&apos;p&apos;);document.body.appendChild(p); Node.removeChild()方法接受一个 子节点 作为参数，用于从当前节点移除该子节点。它返回被移除的子节点。 123var divA = document.getElementById(&apos;A&apos;);divA.parentNode.removeChild(divA);//注意：是在其父节点上调用，而不是被移除的节点。 任务15 和 任务20当开始遇到较为复杂一点的功能，首先要做的就是理清逻辑，比如任务15我们需要：得到数据；对数据排序；对数据渲染；给按钮绑定函数；初始化。在处理数据时我们常常对字符串进行操作，主要有这些属性和方法： length属性，返回字符串的长度。 concat()方法，用于合并两个字符串，返回一个新的字符串，不改变原字符串。 slice()方法，用于从原字符串中取出子字符串，接受两个参数，一个是起始位置，一个结束位置(不含该位置)，这个方法不会改变原字符串。 substr()方法，用于从原字符串中取出子字符串，接受两个参数，一个是起始位置，一个是子字符串的长度，不改变原字符串。 trim()方法，用于去除字符串 两端 的空格，返回一个新的字符串。 match()方法，用于确定原字符串是否匹配某个字符串，如果有则返回一个数组，成员为匹配的第一个字符串。可接受正则表达式。 replace()方法，用于替换匹配的字符串。 split()方法，按照给定的规则来分割字符串，返回一个有分割出来的子字符串组成的数组。 任务16 和 任务18除了字符串，也常常要对Array对象进行操作。最常用的有： toString()方法返回数组的字符串形式。 push()方法用于在数组的末端添加一个或者多个元素，并且返回 添加新元素后的数组长度，这个方法会改变原数组。 pop()方法用于删除数组的最后一个元素，并且 返回该元素，这个方法会改变原数组。 shift()方法删除数组的第一个元素，并且 返回该元素 ，这个方法会改变数组。 unshift()方法给数组的第一位置添加元素并且返回添加新元素的数组长度，这个方法会改变数组。 jion()方法以参数作为分隔符，将所有数组成员组成一个字符串返回，如果不提供参数，默认用逗号。 当取得某个input的值后我们需要通过正则表达式来判断是否符合我们的限定，比如在任务16中，用户输入的城市名必须为中英文字符，空气质量指数必须为整数，就可以通过如下来匹配：1234567891011121314function addAqiData()&#123; var cityStr = document.getElementById(&apos;aqi-city-input&apos;).value.trim(); var numStr = document.getElementById(&apos;aqi-value-input&apos;).value.trim(); if(!cityStr.match(/^[A-Za-z\u4E00-\u9FA5]+$/))&#123; alert(&apos;城市名称必须为汉字或英文字符！&apos;); return; &#125; if(!numStr.match(/^\d+$/))&#123; alert(&apos;空气质量指数必须是整数&apos;); return; &#125; aqiData[cityStr] = numStr;&#125; 在任务16中我们需要为每一个项绑定删除事件。这时，我们要用到事件代理，由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。1234var table =document.getElementById(&apos;aqi-table&apos;);table.addEventListener(&apos;click&apos;,function(event)&#123; if(event.target &amp;&amp; event.target.nodeName === &apos;BUTTON&apos;)&#123; delBtnHandle(event.target); 上面代码的click事件的监听函数定义在节点，但是实际上，它处理的是子节点的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而且以后再添加子节点，监听函数依然有效。 文章参考JavaScript 标准参考教程（alpha）MDN javascript]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用 jQuery 实现一个清单列表小应用]]></title>
      <url>%2F2017%2F02%2F23%2Ftitle-%20%E4%BD%BF%E7%94%A8%20jQuery%20%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95%E5%B0%8F%E5%BA%94%E7%94%A8%20%2F</url>
      <content type="text"><![CDATA[摘要利用 jQuery 做了一个任务清单的网页小应用，实现了其中的一些基本功能。进一步熟悉了 jQuery 的一些基本的操作和方法。第一次使用了 local storage，不过使用了相关的库Store.js。对本地存储的数据保存方式以及JSON还得再抽个时间学一下，算是知其然不知其所以然。遇到了不小的困难，主要存在于下面两个方面：数据的存储和基本概念的理解。意外的收获是学会了利用console.log的检查代码bug。这篇文章主要记述过程和思路，以及一些写代码过程中的反思。 正文 困难与反思假如我在写这篇文章之前先画出一个脑图整理思路的话 (上面这个图是后面整理的 )，我想遇到的问题可能会少很多。假如一上来对要实现的功能的逻辑没有清晰的思路，我发现时间大多数都用来修复函数调用等等所出现的 bug 上面了。而且，假如逻辑清晰，思路很明了的话修复bug的也会变的很快。我想下次再写，一定先要把逻辑搞清楚。比如要实现其中的提交Task功能。 首先我们需要监听提交按钮，是否输入了内容 假如没有或为空则返回，否则 将输入的值推入 Task 列表 然后更新数据 渲染 Task 列表 在渲染的过程中用循环去遍历每个Task 判断单个Task是否已经完成 已完成的渲染已完成的CSS样式 未完成的渲染未完成的结构和样式 监听其他操作 有个清晰的逻辑我们就可以利用Jquery来去实现这个功能了。 我们需要监听提交按钮，我们可以用jquery 的.on()来添加点击事件，将点击触发的函数可以单独来写 我们可以利用.find()来查找input按钮，将val()得到的值复制给变量 将新得到的Task利用.push()给需要渲染的任务列表 写一个刷新数据的函数，将Task列表传入随后再调用我们的渲染函数 渲染函数中我们利用for循环来首先判断每个Task的状态分别来渲染 将渲染好的内容利用prepend或者append结构中区 监听其他事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//部分代码，点击 [TODO](https://github.com/CChenYixin/JavaScript_demo/tree/master/demo_MY%20TODO) 访问完整代码。$form_add_task.on(&apos;submit&apos;,on_add_task_form_submit);//监听提交按钮并添加事件function on_add_task_form_submit(e)&#123; var new_task=&#123;&#125;,$input; //禁用默认行为 e.preventDefault(); //获取新task的值 $input = $(this).find(&apos;input[name=content]&apos;); new_task.content = $input.val(); //如果新task的值为空则返回，否则继续执行 if(!new_task.content) return; // 存入新task task_list.push(new_task); if(add_task(new_task))&#123; // render_task_list(); $input.val(null); &#125;&#125;//添加taskfunction add_task(new_task)&#123; //更新localstrage refresh_task_list(); // console.log(&apos;task_list&apos;,task_list); return true;&#125;//更新localstroage并刷新function refresh_task_list () &#123; store.set(&apos;task_list&apos;, task_list); render_task_list(); &#125;//渲染task列表function render_task_list()&#123; // console.log(&apos;1&apos;,1); // console.log(&apos;task_list&apos;,task_list); var $task_list=$(&apos;.task-list&apos;); $task_list.html(&apos;&apos;); var complete_items =[]; for(var i = 0;i&lt;task_list.length;i++)&#123; var item = task_list[i]; if(item &amp;&amp; item.complete)&#123; complete_items.push(item); var $complete_task = render_task_item(item,i); if(!$complete_task) continue; $complete_task.addClass(&quot;completed&quot;); $task_list.append($complete_task); &#125;else&#123; $task = render_task_item(item,i); $task_list.prepend($task); &#125; &#125; $task_delete_trigger = $(&apos;.action.delete&apos;); $task_detail_trigger= $(&apos;.action.detail&apos;); $checkbox_complete = $(&apos;.complete&apos;); listen_task_delete(); listen_task_detail(); listen_checkbox_complete();&#125; function render_task_item(data,index)&#123; if(!data||!index) return; var list_item_item = &apos;&lt;div class=&quot;task-item&quot; data-index=&quot;&apos;+ index +&apos;&quot;&gt;&apos;+ &apos;&lt;span&gt;&lt;input class=&quot;complete&quot;&apos; + ( data.complete ? &apos;checked&apos;:&apos;&apos;) +&apos; type=&quot;checkbox&quot;&gt;&lt;/span&gt;&apos;+ &apos;&lt;span class=&quot;text-content&quot;&gt;&apos;+ data.content + &apos;&lt;/span&gt;&apos;+ &apos;&lt;span class=&quot;action delete&quot;&gt;删除&lt;/span&gt;&apos;+ &apos;&lt;span class=&quot;action detail&quot;&gt;详细&lt;/span&gt;&apos;+ &apos;&lt;/div&gt;&apos;; return $(list_item_item); &#125; bug 和反思逻辑清晰的找bug也会快一点。尤其是可以利用console.log()的方式。除去那些依靠JShint就可以排查的bug，首先我们可以先确定bug产生的大体范围，根据逻辑顺序，来打印console.log();一步步的来测试就可以精准的确定bug产生的原因。不过暂时不知道那些动辄上万行代码是如何debug的，查找资料的时候发现chrome自带断点测试，也要抽时间来学习一下。 npm的使用npm 是 Node 的模块管理器，功能极其强大。我们根据一行命令，就能安装别人写好的模块。 123$ npm install &lt;packageName&gt;//卸载$ npm uninstall express 模块的安装过程如下： 发出npm install命令 npm 向 registry 查询模块压缩包的网址 下载压缩包，存放在~/.npm目录 解压压缩包到当前项目的node_modules目录 我们可以在安装的时候加上--save-dev： 当你为你的模块安装一个依赖模块时，正常情况下你得先安装他们（在模块根目录下npm install module-name），然后连同版本号手动将他们添加到模块配置文件package.json中的依赖里（dependencies）。-save和save-dev可以省掉你手动修改package.json文件的步骤。spm install module-name -save 自动把模块和版本号添加到dependencies部分spm install module-name -save-dve 自动把模块和版本号添加到devdependencies部分 在使用npm感觉很方便，另外想到的还是必须要学习git，虽然再学习初期为了节省时间用了github的客户端来上传代码，但是最终用的还是git，而且用git会更加节省时间。 总结 写代码前有一个清晰的逻辑。 基础概念的掌握和理解是最重要的没有之一。 要抽时间深度掌握 git,JSON,以及是改学学后端的一些知识了，至少要熟悉借口之类的。 感觉最近的学习有点懈怠了，要加油。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[立即执行函数表达式 IIFE]]></title>
      <url>%2F2017%2F01%2F18%2Ftitle-%20%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%20IIFE%20%2F</url>
      <content type="text"><![CDATA[摘要有半个月没有写文章，原因是作为一名前端新手 Javascript 中有太多太多的概念，最近大概开始对近段时间的学习一些知识的总结。本篇文章分为两个部分阐述常常会遇到和使用的立即执行函数 IIFE ，分别是立即执行函数是什么，以及为什么会使用这个函数。 立即执行函数 IIFE 是什么？定义类似于下面这两种形式，当我们在定义了函数之后需要立即调用时，可以通过加 () 的方式来调用函数。但是，由于function这个关键字即可以被当做语句，也可以当做表达式。所以为了避免解析上的歧义，JavaScript引擎规定，如果function关键字出现在行首，一律解释成语句。所以我们不能在函数定义后直接加 () 来立即调用它，而最简单的办法就是将function放在一个()中让引擎将其理解成一个表达式。这种可以立即调用函数的方法被称作“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称IIFE。 123456789101112// 函数声明function f() &#123;&#125;// 函数表达式var f = function f() &#123;&#125;// SyntaxError: Unexpected token (function()&#123; /* code */ &#125;();//IIFE(function()&#123; /* code */ &#125;());(function()&#123; /* code */ &#125;)(); 具体分析首先，我们分析普通的函数声明和调用方式：12345678910111213141516// 声明函数f1function f1() &#123; console.log(&quot;f1&quot;);&#125;// 通过()来调用此函数f1();// 或者// 建立匿名函数并赋予变量f2var f2 = function() &#123; console.log(&quot;f2&quot;);&#125;// 通过()来调用此函数f2(); 这两种方式都是用显示的方式声明函数，然后在函数名之后通过 () 来调用，自然而然，我们回想是不是可以类似直接调用匿名函数呢？12function()&#123; /* code */ &#125;();// SyntaxError: Unexpected token ( 浏览器会报错：SyntaxError: Unexpected token (，正如在定义部分说过，原因是由于function这个关键字即可以被当做语句，也可以当做表达式。JavaScript 的解释器会默认的将遇到的function关键字当做函数声明语句来进行解释。但是，函数声明的语句是这样的：123function name([param] [, param] [..., param]) &#123; statements&#125; 所以在匿名函数后面直接加 ()的调用方式是用语法错误的。那么我们就需要通过将function放在一个()中的形式让解释器把()中的内容当作表达式去执行这样就能避免错误，其中我们最常见最常使用的方式有下面两种： 12//方法一(function()&#123; /* code */ &#125;)(); 由于把函数的声明写在了()之中，所以解释器以表达式（expression）来解析其中代码而不会抛出错误，当我们直接向 () 中传入声明函数会直接返回此函数：123// 如果传入字面量（literal），则返回表达式（expression）(1) // 1 (function()&#123;console.log(&quot;f&quot;);&#125;) // function () &#123;console.log(&quot;f&quot;)&#125; 所以方法一其实就是我们调用函数的通用方式。12//方法二(function()&#123; /* code */ &#125;()); 方法二就更容易理解直接把()中的内容当作表达式来进行解释。和方法一在结果上没有什么区别。以上便是具体分析的过程。 为什么使用立即执行函数表达式 IIFE？ 传统的方法比较，定义和执行分开写 传统的方法直接污染全局命名空间（浏览器里的 global 对象，如 window） 在JavaScript没有块作用域（block），只有函数作用域，在同时调用多个库的情况下，很容易造成对象或者变量的覆盖，而在IIFE内部会形成一个单独的作用域，可以封装一些外部无法读取的私有变量。1234567891011121314151617181920212223242526272829// 创建一个立即调用的匿名函数表达式// return一个变量，其中这个变量里包含你要暴露的东西// 返回的这个变量将赋值给counter，而不是外面声明的function自身var counter = (function () &#123; var i = 0; return &#123; get: function () &#123; return i; &#125;, set: function (val) &#123; i = val; &#125;, increment: function () &#123; return ++i; &#125; &#125;;&#125; ());// counter是一个带有多个属性的对象，上面的代码对于属性的体现其实是方法counter.get(); // 0counter.set(3);counter.increment(); // 4counter.increment(); // 5counter.i; // undefined 因为i不是返回对象的属性i; // 引用错误: i 没有定义（因为i只存在于闭包） 函数声明和函数表达式要理解立即执行函数，最关键的是需要理解函数声明、函数表达式的基本概念和区别。 函数声明 (function 语句):123function name([param[, param[, ... param]]]) &#123; statements&#125; name：函数名；param：被传入函数的参数的名称,一个函数最多可以有255个参数；statements：这些语句组成了函数的函数体。 函数表达式 (function expression):123function [name]([param] [, param] [..., param]) &#123; statements&#125; name：函数名,可以省略,省略函数名的话,该函数就成为了匿名函数；param：被传入函数的参数的名称,一个函数最多可以有255个参数；statements：这些语句组成了函数的函数体。 虽然都可以定义函数，但最大的区别在于：解析器会率先读取函数声明，使其在执行任何代码之前就可以访问（也就是 函数声明提升）；而函数表达式则需要解析器执行到它所在的代码行才会被解释执行。123456789function test() &#123; foo(); function foo() &#123; alert(&quot;我是会出现的啦……&quot;); &#125;&#125;test(); 12345678910function test() &#123; foo(); var foo = function() &#123; alert(&quot;我不会出现的哦……&quot;); &#125;&#125;test();` 在上面的第一个例子中foo()是一个声明，函数声明会被提升，函数声明会连通命名和函数体一起被提升至作用域顶部，在执行 foo() 之前，作用域就知道函数 foo 的存在了。随意例子中的 alert 会被显示出来。而在例子二中由于foo()是函数表达式， 在执行 foo() 之前，作用域只知道 foo 的命名，不知道它到底是什么，所以执行会报错：1&quot;TypeError: foo is not a function 函数表达式只有命名会被提升，定义的函数体则不会。 参考文章JavaScript中的立即执行函数表达式JavaScript标准教程参考 —— 阮一峰函数声明与定义，作用域，函数声明与表达式的区别深入浅出JavaScript：定义函数（函数声明&amp;函数表达式）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分别利用 JavaScript 和 CSS 实现tab选项卡切换]]></title>
      <url>%2F2017%2F01%2F03%2Ftitle-%20%E5%88%86%E5%88%AB%E5%88%A9%E7%94%A8%20JavaScript%20%E5%92%8C%20CSS%20%E5%AE%9E%E7%8E%B0tab%E9%80%89%E9%A1%B9%E5%8D%A1%E5%88%87%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[摘要大概是一次概念整理，原本这个是慕课进阶后面的编程练习，通过这个选项卡切换的小实例理清了原本对 JavaScript 概念的一些错误认识，顺便复习了一下利用 CSS 制作tab选项卡的过程，所以大概整理了一下写成文章。另外尽管如此，这个练习后还是存在一个问题：就是关于JavaScript中的 this 的使用问题，尽管了解了关键字 this 总是指向调用该方法的对象，但是这较为抽象的概念在实际运用和理解中还是有点问题，暂时还没有解决，特此记录下。可以这个需要大量的练习才可能摸清this的真正概念和使用方法吧。17年1月18号更新：文章写于刚开始学习JS时，文中方法二 Javascript 与 CSS 耦合是一种并不合适的写法。 正文CSS 实现tab选项卡切换效果如下： HTML部分：12345678910111213141516171819202122232425div id=&quot;tabs&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; name=&quot;nav&quot; id=&quot;nav1&quot; checked&gt; /*核心代码*/ &lt;label for=&quot;nav1&quot;&gt;房产&lt;/label&gt; &lt;div class=&quot;tab tab1&quot;&gt; 275万购昌平邻铁三居 总价20万买一居&lt;br/&gt;200万内购五环三居 140万安家东三环&lt;br/&gt;北京首现零首付楼盘 53万购东5环50平&lt;br/&gt;京楼盘直降5000 中信府 公园楼王现房 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; name=&quot;nav&quot; id=&quot;nav2&quot;&gt; &lt;label for=&quot;nav2&quot;&gt;家具&lt;/label&gt; &lt;div class=&quot;tab tab2&quot;&gt; 40平出租屋大改造 美少女的混搭小窝&lt;br/&gt;经典清新简欧爱家 90平老房焕发新生&lt;br/&gt;新中式的酷色温情 66平撞色活泼家居&lt;br/&gt;瓷砖就像选好老婆 卫生间烟道的设计 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; name=&quot;nav&quot; id=&quot;nav3&quot;&gt; &lt;label for=&quot;nav3&quot;&gt;二手房&lt;/label&gt; &lt;div class=&quot;tab tab3&quot;&gt; 通州豪华3居260万 二环稀缺2居250w甩&lt;br/&gt;西3环通透2居290万 130万2居限量抢购&lt;br/&gt;黄城根小学学区仅260万 121平70万抛!&lt;br/&gt;独家别墅280万 苏州桥2居优惠价248万 &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 对于这种类似与选项卡的内容，最好利用 ul 和 li 把对应tab下的内容放在一起。在这个选项卡切换的 HTML 核心部分：首先，我们要实现点击tab实现相关内容的切换，这就需要用到input元素以及其相关的属性name，对于一组input单选按钮，我们需要设置它们的name为相同的值，确保当选中其中一个时，其他的不会被选中。其次，我们需要用到label，label元素不会向用户呈现任何特殊的样式。不过，它为鼠标用户改善了可用性，因为如果用户点击 label 元素内的文本，则会切换到控件本身。这样我们就可以隐藏input元素了，点击label区域就可以了，label标签的 for 属性应该等于input的 id 元素，以便将它们捆绑起来。这样HTML的核心部分基本设置好了，另外给第一个input设置checked保证其在选中状态。不然后面CSS部分display设置都为 none 后页面载入空空如也。 CSS 部分(只标注了核心部分)：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style media=&quot;screen&quot;&gt; ... #tabs ul li .tab &#123; display: none; /*核心代码*/ position: absolute; width: 300px; height: 100px; top: 30px; left: 0; text-align: center; &#125; #tabs ul li input &#123; display: none; &#125; #tabs ul li label &#123; display: inline-block; text-align: center; float: left; width: 100px; height: 30px; line-height: 30px; background-color: #eee; cursor: pointer; &#125; #tabs ul label:hover &#123; background-color: #666; color: white; &#125; #tabs ul li [id^=&apos;nav1&apos;]:checked~.tab1 &#123; display: block; /*核心代码*/ &#125; #tabs ul li [id^=&apos;nav2&apos;]:checked~.tab2 &#123; display: block; /*核心代码*/ &#125; #tabs ul li [id^=&apos;nav3&apos;]:checked~.tab3 &#123; display: block; /*核心代码*/ &#125;&lt;/style&gt; 我们的核心思想是：当相应 tab 的label被点击时候，该 tab 对应的 div 展示。为此，首先我们将tab对应的 div 部分设置为 display = none; 然后来实现我们的效果：点击展示。这部分我们要利用 CSS 选择器来实现。首先，我们利用 [attribute^=value]选择器来选择相应的 input选择，然后使用 :checked （这个是必要的）选择器选择状态为选中状态的input元素，再利用~选择器，选择相应的div的类名。到此为止，利用CSS实现选项卡的切换就已经完成了，总结下核心就是利用选择器选中相应的input实现对应div的展现。 JavaScript 实现tab选项卡切换方法一：利用style语法效果依旧： HTML部分：123456789101112131415161718&lt;div id=&quot;tabs&quot;&gt; &lt;ul&gt; &lt;li&gt;房产&lt;/li&gt; &lt;li&gt;家具&lt;/li&gt; &lt;li&gt;二手房&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;con&quot;&gt; &lt;div&gt; 275万购昌平邻铁三居 总价20万买一居&lt;br/&gt;200万内购五环三居 140万安家东三环&lt;br/&gt;北京首现零首付楼盘 53万购东5环50平&lt;br/&gt;京楼盘直降5000 中信府 公园楼王现房 &lt;/div&gt; &lt;div&gt; 40平出租屋大改造 美少女的混搭小窝&lt;br/&gt;经典清新简欧爱家 90平老房焕发新生&lt;br/&gt;新中式的酷色温情 66平撞色活泼家居&lt;br/&gt;瓷砖就像选好老婆 卫生间烟道的设计 &lt;/div&gt; &lt;div&gt; 通州豪华3居260万 二环稀缺2居250w甩&lt;br/&gt;西3环通透2居290万 130万2居限量抢购&lt;br/&gt;黄城根小学学区仅260万 121平70万抛!&lt;br/&gt;独家别墅280万 苏州桥2居优惠价248万 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 首先，上面这个部分div class=&quot;con&quot;这个不是必要的，只是为了练习JS额外添加的一层。HTML和CSS 部分没什么好说的，因为不需要CSS来控制，我们可以把内容div部分和tab部分分开。 JavaScript部分：12345678910111213141516171819&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var oTab = document.getElementById(&quot;tabs&quot;); var oUl = oTab.getElementsByTagName(&quot;ul&quot;)[0]; var oLis = oUl.getElementsByTagName(&quot;li&quot;); var ocon = document.getElementsByClassName(&quot;con&quot;)[0]; var oDivs = ocon.getElementsByTagName(&quot;div&quot;); for (var i = 0, len = oLis.length; i &lt; len; i++) &#123; oLis[i].index = i; oLis[i].onclick = function() &#123; for (var n = 0; n &lt; len; n++) &#123; oDivs[n].style.display = &quot;none&quot;; &#125; oDivs[this.index].style.display = &quot;block&quot;; &#125; &#125;; &#125;&lt;/script&gt; 我们需要的效果是选择tab标签展现相应的内容，为此我们要获得相应的li和其div；这时候我们就需要用到这一大推方法： getElementById()：返回对拥有指定 id 的第一个对象的引用。 getElementsByTagName()：返回带有指定标签名的对象集合。 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 需要注意的是，后面两个方法返回都是一个集合，所以上面JS代码中赋值时需要注意到底是需要这个集合还是这个集合中某个元素。这也是上面这两个方法后面添加[0]的原因。接下是代码的核心部分，我们需要的效果选择相应的tab标签展现相应的内容，转化为代码就是：选择其中一个，其他的隐藏。 我们利用for循环来实现这个效果，首先我们给li的集合建立索引，其次在for循环中建立 onclick事件 ：123456oLis[i].onclick = function() &#123; for (var n = 0; n &lt; len; n++) &#123; oDivs[n].style.display = &quot;none&quot;; &#125; oDivs[this.index].style.display = &quot;block&quot;;&#125; 函数中的循环表示：所有div的 display:none;,然后函数外利用关键字 this （关键字 this 总是指向调用该方法的对象）来调用相应被点击了的div，再使用style语法让display设置为block。 换句话说：内层循环表示，第一次遍历li，让所有的li的dislay设置为none；内层循环结束，然后再给当前被选的li的dispaly赋值为block； 方法二：利用className 和CSS配合HTML部分：123456789101112131415161718&lt;div id=&quot;tabs&quot;&gt; &lt;ul&gt; &lt;li&gt;房产&lt;/li&gt; &lt;li&gt;家具&lt;/li&gt; &lt;li&gt;二手房&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;con&quot;&gt; &lt;div&gt; 275万购昌平邻铁三居 总价20万买一居&lt;br/&gt;200万内购五环三居 140万安家东三环&lt;br/&gt;北京首现零首付楼盘 53万购东5环50平&lt;br/&gt;京楼盘直降5000 中信府 公园楼王现房 &lt;/div&gt; &lt;div class=&quot;hide&quot;&gt; 40平出租屋大改造 美少女的混搭小窝&lt;br/&gt;经典清新简欧爱家 90平老房焕发新生&lt;br/&gt;新中式的酷色温情 66平撞色活泼家居&lt;br/&gt;瓷砖就像选好老婆 卫生间烟道的设计 &lt;/div&gt; &lt;div class=&quot;hide&quot;&gt; 通州豪华3居260万 二环稀缺2居250w甩&lt;br/&gt;西3环通透2居290万 130万2居限量抢购&lt;br/&gt;黄城根小学学区仅260万 121平70万抛!&lt;br/&gt;独家别墅280万 苏州桥2居优惠价248万 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS部分：1234.../*省略*/.hide &#123; display: none;&#125; JavaScript部分：12345678910111213141516171819202122&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var oTab = document.getElementById(&quot;tabs&quot;); var oUl = oTab.getElementsByTagName(&quot;ul&quot;)[0]; var oLis = oUl.getElementsByTagName(&quot;li&quot;); var ocon = document.getElementsByClassName(&quot;con&quot;)[0]; var oDivs = ocon.getElementsByTagName(&quot;div&quot;); for (var i = 0, len = oLis.length; i &lt; len; i++) &#123; /*定义一个index属性对aBtn进行编号*/ oLis[i].index = i; oLis[i].onclick = function() &#123; for (var n = 0; n &lt; len; n++) &#123; /*这里是相对于未被点击的部分的样式*/ oDivs[n].className = &quot;hide&quot;; &#125; /*通过之前的index编号绑定指定的div文本*/ oDivs[this.index].className = &quot;&quot;; &#125; &#125;; &#125;&lt;/script&gt; 和方法一基本上类似，CSS部分首相将其他两个隐藏，然后实现用JS代码实现选择其中一个，其他的隐藏。不过在设置的部分利用的className属性来设置。 参考文章ECMAScript 对象作用域 HTML DOM - 改变 CSS]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动 Web 开发小记]]></title>
      <url>%2F2016%2F12%2F27%2Ftitle-%20%E7%A7%BB%E5%8A%A8%20Web%20%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0%20%2F</url>
      <content type="text"><![CDATA[摘要大概记述了初次接触移动 Web 页面布局实践中遇到的一些问题和值得注意的地方。具体包括了移动前端开发基本的概念，移动页面开发相关的一些meta标签，相对单位 rem ，与响应式图片的一些总结。 正文移动前端开发的大体印象移动前端开发是一个很大的概念，除了基本的前端知识外，还需要掌握一些PPI，像素，DPI等知识，对自己这种小白来说，学习过程中的一大体验就是概念多，还没有有个全局的印象首先被基础概念淹没了。所以个人感觉首先要对移动前端开发有个大体的印象。具体来说的移动前端开发包括了以下几种类型： Native App（ 原生APP ）：完全使用移动设备系统语言写成的客户端。iPhone、iPad 就是纯Object-C，安卓就是纯JAVA, 具有极强的交互性。一般静态资源都是在本地的。浏览使用方便，体验度高。 Web App：在移动设备的浏览器中的应用，不再是操作系统。说白了就是一个触屏版的网页，只能在浏览器中打开。资源一般都在网络上，IOS支持可以在桌面创建访问的快捷方式。 Hybrid App：用原生系统语言写了个容器，然后在里面运行 web 页面，资源一般在本地或者网络都可以。 移动前端开发中的 meta 元素meta 元素 标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 —— W3School 移动设备viewport可以让布局在移动浏览器上显示的更好，之所有会有要用到 viewport，原因是在移动浏览器中，通常会以一个比屏幕更宽的虚拟的窗口中渲染，从而无需将页面的所有部分压缩到屏幕中（这样会把很多没有针对移动端进行优化的站点打乱）。用户可以通过平移和缩放来浏览页面的不同区域。1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no&quot;/&gt; 其中： content 是 meta 元素中的必要属性，定义与http-equiv或name属性相关的元信息 name 把 content 属性关联到一个名称 initial-scale 为初始的缩放比例，范围从&gt;0 到10 minimum-scale 允许用户缩放到的最小比例 maximum-scale 允许用户缩放到的最大比例 user-scalable 用户是否可以手动缩 (no,yes) 相对单位 remrem（font size of the root element）是指相对于根元素的字体大小的单位。通过设置html的字体大小就可以控制rem的大小。123456789html &#123; font-size: 62.5%;&#125;body &#123; font-size: 1.4rem; /* 14px */&#125;h1 &#123; font-size: 2.4rem; /* 24px */&#125; 对于移动前端开发来说，我们在页面布局中有可能采用宽度百分比，高度用px固定的方式，但在某些屏幕下页面元素可能被拉长导致宽度百分比但高度没变就使得视觉上显示的不协调。要么采用响应式，但这种方式工作大，维护性难。要么采用 viewport 缩放的方式，但也有可能造成在缩放中页面糊掉的情况。这时候我们就可以采用 rem 的方式开适配。 rem不仅仅用于字体，同样也可以应用于宽高，边距等等，这样我们就可以通过设置html的字体大小就可以控制rem的大小。具体的来说，我们可以通过 JS 计算的方式去设置 font-size，因为暂时没有学习 JS ，暂时不做叙述。再者就是采用 media query 的方式来实现适配。例如：12345678910111213141516171819202122232425262728html &#123; font-size : 20px;&#125;@media only screen and (min-width: 401px)&#123; html &#123; font-size: 25px !important; &#125;&#125;@media only screen and (min-width: 428px)&#123; html &#123; font-size: 26.75px !important; &#125;&#125;@media only screen and (min-width: 481px)&#123; html &#123; font-size: 30px !important; &#125;&#125;让@media only screen and (min-width: 569px)&#123; html &#123; font-size: 35px !important; &#125;&#125;@media only screen and (min-width: 641px)&#123; html &#123; font-size: 40px !important; &#125;&#125; 弹性图片max-width方式响应式 web 设计意味着，不仅我们的布局能基于设备特征变化，内容也能。对于图片来说，对于不同的设备，需要拉伸或者收缩图片。这时候我们可以在其中加上如下 CSS 样式：1234img&#123; max-width:100%; height:auto;&#125; max-width:100%的设置，以确保图像永远不会超越其父容器的宽度。如果父容器的宽度收缩小于图像的宽度，图像将随之缩小。 height:auto的设置可以确保当有这种情况发生时，图像将以自身的宽高比保留。 picture方式是HTML5一个新的元素。它可以通过使用 media 属性的方式来让浏览器根据当前的页面选择加载最合适的图片大小。 HTML 元素是一个容器，用来为其内部特定的 元素提供多样的 元素。浏览器会根据当前页面（即图片所在的盒子的容器）的布局以及当前浏览的设备（比如普通的屏幕和高清屏幕）去从中选择最合适的资源。 文章如何使用 HTML5 的picture元素处理响应式图片对此有详细的论述，以下内容皆引用自原文： 基本工作步骤如下： 创建标签。 在这些标签内创建一个你想用来执行任何一个特性的元素。 添加一个media属性，用来包含你想要的特性，如视口的当前高度(viewport height)，宽度(width)，方向(orientation)等。 添加一个srcset属性与相应的图像文件名相匹配，进行加载。如果你想提供不同的像素密度，例如Retina显示屏，你可以添加额外的文件名到你的srcset属性中， 添加一个回退的元素。 可以看个简单的例子，用来检查视口是否小于768px，如果小于就加载一个较小的图像：12345&lt;picture&gt; &lt;source srcset=&quot;person_small.jpg&quot; media=&quot;(max-width: 768px)&quot;&gt; &lt;source srcset=&quot;person_default.jpg&quot;&gt; &lt;img srcset=&quot;person_default.jpg&quot; alt=&quot;This is King&quot;&gt;&lt;/picture&gt; 可以看到在屏幕&lt;=768px的时候加载的是person_small.jpg当屏幕&gt;768px的时候，加载的是person_default.jpg 不过这是一个实验中的功能，Chrome，Firefox和Opera浏览器都已经实现了对元素的支持。在不久的将来，在其他浏览器也将得到广泛的支持。 参考文章常用meta整理移动前端不得不了解的html5 head 头标签在移动浏览器中使用viewport元标签控制布局如何使用 HTML5 的picture元素处理响应式图片移动前端开发和 Web 前端开发的区别是什么？移动开发规范概述移动适配利器 remweb app变革之rem]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IFE task 8-12 笔记]]></title>
      <url>%2F2016%2F12%2F26%2Ftitle-%20IFE%20task%208-12%20%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[摘要文章为百度前端技术学院2016年任务 8-12 的笔记，CSS 部分基本结束。本文大概记述了后半部分任务中的栅格化布局与 Flexfox 布局的一些笔记和需要注意的地方。 正文栅格化布局栅格化布局的核心是预设好的列宽和媒体查询。具体来说， 首先，我们可以根据需要创建一系列预设好宽度的列，其次，通过设置不同的类名引用它们，最后通过媒体查询来判断具体情况下需要引用哪种样式布局，最终实现不同终端下都能让布局完美展示的响应式设计。比较流行 Bootstrap 就是基于这种简单又实用的设计方式，通过 link 引入的方式可以快速的开发适用于不同设备的响应式 WEB 项目。这里以任务 8 为例结合这篇文章 Creating Your Own CSS Grid System 简单的回顾一下栅格化布局需要注意的部分。 一个简单的栅格化布局包括以下部分： 容器 - container 行 - rows 列 - columns 间隙 - 列之间的空隙（gutters） 容器 - container首先，栅格化布局的页面被包含在一个 .container 容器中，通常情况下宽度为100%，我们也可以通过 max-width 来设置最大的宽度。 1234.container &#123; width : 100%; max-width : 1200px; &#125; 行 - rows 行设置的目的是保证列们在它的包裹中而不是溢出到其他行中去。为了达到这个目的，我们需要使用清除浮动的技巧来保证子列们仍旧在这一行中。 123456.row:before,.row:after&#123; content: &quot;&quot;; display: table; clear: both;&#125; 列 - columns列的设置是栅格化布局中最核心的部分之一。首先要将宽度划分为等分的列，可以根据需要设置不同的宽度，在 Bootstrap 框架中预设的列数为12等分。 123456789101112.col-1 &#123;width: 8.33%;&#125;.col-2 &#123;width: 16.66%;&#125;.col-3 &#123;width: 25%;&#125;.col-4 &#123;width: 33.33%&#125;.col-5 &#123;width: 41.66%;&#125;.col-6 &#123;width: 50%&#125;.col-7 &#123;width: 58.33%;&#125;.col-8 &#123;width: 66.66%;&#125;.col-9 &#123;width: 75%;&#125;.col-10 &#123;width: 83.33%&#125;.col-11 &#123;width: 91.66%&#125;.col-12 &#123;width: 100%&#125; 设置好列的宽度后，利用 float 浮动的方式进行布局，如果我们不设置列的高度，那么这些浮动的列将会互相堆叠在前者的上面。为了避免出现这样的情况，我们需要在浮动列的同时给他们一个最小高度1px。1234[class*=&apos;col-&apos;]&#123; float: left; min-height: 1px;&#125; 接下来我们已经可以引用并进行布局了。 12345678&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-6&quot;&gt; &lt;span&gt;两栏&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;col-6&quot;&gt; &lt;span&gt;两栏&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 列之间的空隙（gutters）在一般的盒模型下，如果我们设置一个宽度为200px，而实际呈现的盒子的宽度可能会大于200px(除非没有左右边框和左右补白)。但是当我们使用了 box-sizing:border-box属性后，假如我们要设置一个宽度为200px的盒子，那么只需要直接设置宽度为200px，当再设置它的左右边框和左右补白后，它的内容区会自动调整。 这就使得我们可以借助border-box模型，轻松设置列之间的空隙。123456789101112/*-- setting border box on all elements inside the grid --*/.grid-container *&#123; box-sizing: border-box;&#125;[class*=&apos;col-&apos;]&#123; float: left; min-height: 1px; width: 16.66%; /*-- our gutter --*/ padding: 12px;&#125; @media媒体查询至此我们便可以通过媒体查询来设置不同设备或屏幕大小下的布局效果了。以任务 8 为例子： Flexbox布局不同于栅格化布局利用 CSS 属性实现响应式开发，Flexbox 布局本身是一个布局模块，它包含着父元素 flex container 和子元素 flex items 属性。优点是尤其适合移动端 WEB 网页开发，缺点是在PC端的兼容性上暂时不完全，而且由于本身是一个布局模块所以不需要额外书写CSS样式，相比栅格式布局需要额外书写样式可能带来的渲染时间延长的缺点，Flexbox 十分适合响应式开发。 根据我个人的理解把 Flexbox布局分为两部分理解：轴相关和项目相关。 轴相关 使用Flexbox 布局 123section&#123; display:flex;&#125; 轴方向 flex-direction设定伸缩容器的主轴的方向，默认 row。 row(默认值)：在“ltr”排版方式下从左向右排列；在“rtl”排版方式下从右向左排列。 row-reverse：与row排列方向相反，在“ltr”排版方式下从右向左排列；在“rtl”排版方式下从左向右排列. column：类似 于row，不过是从上到下排列. column-reverse：类似于row-reverse，不过是从下到上排列。 换行 flex-wrap nowrap:flex-wrap的默认值，表示的是伸缩容器为单行。侧轴起点方向等同于当前书写模式的起点或前/头在侧轴的那一边，而侧轴终点方向是侧轴起点的相反方向。 wrap：表示的是伸缩容器为多行。侧轴起点方向等同于当前书写模式的起眯或前/头在侧轴的那一边，而侧轴终点方向是侧轴起点的相反方向。 wrap-reverse：除了侧轴起点与侧轴终点方向交换以外同wrap所起作用相同。 主轴 justify-content设置伸缩项目沿主轴的对齐方式，从而调整伸缩项目之间的间距。比较常用的 center 和 space-between。当我们需要让多个块元素在同一水平线上居中的时候，我们就可以用Flexbox 布局迅速让其居中: 1234.flex-center &#123; display: flex; justify-content: center;&#125; 侧轴 align-items类似与主轴，设置伸缩项目沿侧轴的对齐方式，比如当我们需要让元素水平垂直局居中时，就可以使用 Flexbox 布局： 12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; 项目相关 项目顺序 order默认情况之下，所有的伸缩项目的顺序组都是“0”。我们可以很容易的给每个伸缩项目设置不同的顺序值。更高的值会排在后面，而原来的HTML结构并不会有任何变化。比如我们可以通过以下代码让 .first 排在第一位： 123.first &#123; order: -1;&#125; 项目的弹性 flex flex-grow 定义伸缩项目的扩展能力。比如我们给伸缩项目设置flex-grow：1;那么每个伸缩项目将设置为一个大小相等的剩余空间，相当于等比的方式分配空间。 flex-shrink：定义伸缩项目收缩的能力。注意：负值同样生效。 flex-basis: 设置伸缩基准值，剩余的空间按比率进行伸缩。 这三个属性可以用flex简写，默认值为“0 1 auto”。 相关参考 Creating Your Own CSS Grid System Flexbox详解 Flexbox——快速布局神器 Bootstrap 全局 CSS 样式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IFE task 1-7 笔记]]></title>
      <url>%2F2016%2F12%2F16%2Ftitle-%20IFE%20task%201-7%20%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[摘要文章为百度前端技术学院2016年任务 1-7 的笔记，大概记述了学习和练习中需要注意的地方以及一点点笔记。大体上包括了以下几个方面：三栏布局、CSS 居中方式、CSS 选择器、tansition和CSS 伪类的应用、利用纯 CSS 实现 tab 的方法等等。 注意： 这篇文章写于学习前端不久，可能会出现错误或者概念理解不全面等等纰漏。 正文三栏布局下面的三个布局都是在 具体的情况 下讨论的，具体对应的是任务三。 绝对定位法绝对定位法左右两栏采用绝对定位固定，中间用margin值撑开距离。这种方法内部div顺序随意。 需要注意的是： 如果中间栏含有最小宽度限制，或是含有宽度的内部元素，当浏览器宽度小到一定程度，会发生层重叠的情况。 如练习中所示假如三栏外含有包含框，那么这种办法很难发生效果，原因是左右两栏采取绝对定位，脱离了文档流，当左右两栏高度大于中间时，会在视觉上突破包含框。另外，当浏览器宽度小到一定程度，主体可能溢出包含框。如果要求不是很严格，可以在中间添加个大于左右两栏的高度和 overflow。 外边距负值法(据说又叫圣杯布局)首先，中间的主体要使用双层div。外层宽度100%并且浮动，内部div为真正的内容。 其次，左右栏浮动，且采用margin负值来定位。以左浮动为例，左栏用margin-left为-100%，右边为margin负值本身元素宽度。 需要注意的是： div顺序必须主体内容在前。 另外，如练习中所示假如三栏外含有包含框，那么这种办法也很难发生效果，原因是左右两栏浮动，脱离了文档流，当左右两栏高度大于中间时，会在视觉上突破包含框。另外，当当浏览器宽度小到一定程度，主体可能溢出包含框。如果要求不是很严格，同样在最外层的 container 加上 overflow。 这种方法的好处是兼容性很好，几乎可以兼容各种现代浏览器，核心的思想是给自适应的部分设置宽度100%并且浮动，固定部分利用外边距负值来定位，两栏也是同样的道理。 浮动法最简单最好理解最好用的方法，左栏左浮动，右栏有浮动，中间自适应。 需要注意的是： 主体div放在最后，左右两栏div顺序任意。 最有效果的方式，如练习中所示即使三栏外面再有包含框，也只需在包含框上添加 overflow 即可。 CSS伪类 与 tansitionCSS 的伪类真是好用，在一些小的练习中基本还不是很明显，稍微复杂一点的练习就突出其用处了。比较常用的有这个几个： :first-child 伪类,来选择作为第一个子元素的元素。 :last-of-type伪类，选择其父元素的特定类型的最后一个子元素的每个元素。 :nth-of-type(n) 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素，n 可以是数字、关键词或公式。 :hover 锚伪类,些状态包括：活动状态，已被访问状态，未被访问状态，和鼠标悬停状态。注意这个是用顺序的：1234a:link &#123;color: #FF0000&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */a:active &#123;color: #0000FF&#125; /* 选定的链接 */ 举个比较实用的小例子做个说明： 1234&lt;div&gt;&lt;p&gt; hello world&lt;/p&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; 现在我们给它添加CSS 和伪类：123456789101112131415161718192021div&#123; text-align:center;&#125;p&#123; display:inline-block; border-bottom:2px solid black; /* 底边框黑色 */&#125;p:hover&#123; border-bottom:2px solid red; /* 当鼠标移到此，底边框变成红色 */&#125;span&#123; color: #fff; display: block; width: 30px; height: 20px; margin: 0 auto; border-top: 2px solid red; /* 视觉为宽30px的红色线段 */&#125;span:hover&#123; width: 100px; /* 当鼠标移到此，视觉为宽200px的红色线段 */&#125; 我们可以通过这两种方式添加类似一种下划线的动画效果，不过这样的变化过于生硬，接下来我们就可以使用transition来做一点点小小的优化。transition 属性是一个简写属性，用于设置四个过渡属性: 值 描述 transition-property 规定设置过渡效果的 CSS 属性的名称 transition-duration 规定完成过渡效果需要多少秒或毫秒 transition-timing-function 规定速度效果的速度曲线 transition-delay 定义过渡效果何时开始 其中必须始终设置 transition-duration 属性，否则时长为 0，就不会产生过渡效果。 我们继续完善上面的细节,以 span 为例子：123456789101112span&#123; color: #fff; display: block; width: 30px; height: 20px; margin: 0 auto; border-top: 2px solid red; /* 视觉为宽30px的红色线段 */ transition: width 0.4s ease-in-out; /* ease-in-out 规定以慢速开始和结束的过渡效果 */&#125;span:hover&#123; width: 100px; /* 当鼠标移到此，视觉为宽200px的红色线段 */&#125; 利用纯 CSS 实现 tab这个是在查看别人代码中发现，于是自己实现了一下，使用纯 CSS 制作 tab 切换效果。核心是利用： display:none 和 :checked 来实现。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style media=&quot;screen&quot;&gt; .container&#123; text-align: center; width: 300px; height: 200px; border: 1px solid black; position:relative; &#125; .con&#123; display:none; /*核心代码，使内容隐藏起来*/ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; .con1&#123; &#125; .container input[type=&quot;radio&quot;]:nth-of-type(1):checked~.con1&#123; display: block; /*核心代码，点击出现*/ &#125; .container input[type=&quot;radio&quot;]:nth-of-type(2):checked~.con2&#123; display: block; /*核心代码，点击出现*/ &#125; .container input[type=&quot;radio&quot;]:nth-of-type(3):checked~.con3&#123; display: block; /*核心代码，点击出现*/ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;con&quot; value=&quot;con1&quot; checked&gt; &lt;input type=&quot;radio&quot; name=&quot;con&quot; value=&quot;con2&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;con&quot; value=&quot;con3&quot;&gt; &lt;div class=&quot; con con1&quot;&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot; con con2&quot;&gt;&lt;p&gt;hello girl&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot; con con3&quot;&gt;&lt;p&gt;hello boby&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 不过用纯 CSS 实现 tab 切换的方式还有几种，暂时还在研究当中，这种相对来说比较简单。 CSS 居中方式虽然有这篇万能的文章 Centering in CSS: A Complete Guide，但是在实际应用过程中还是会有很多麻烦，还是基本的概念理解的不清楚。实际应用中来说水平居中用到的多一点，无论是对于行内元素还是块元素来说。垂直居中的话不是很常用，因为如果要求不是很严格的话，都会用到绝地定位来定位，比较常用的是利用行高和高度相等来垂直居中，尤其是在导航栏设置中。设置一个如 td 和 tr 那样的元素中，然后使用 vertical-align 来实现垂直居中偶尔会用到。因为 flex 布局暂时还没有细学。 下面通过几个导航栏的设置来巩固一下，为什么是导航栏呢？因为这个看似简单却可以用到很多知识，定位，浮动，居中等这篇文章提到的所有概念。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;header&#123; position:relative; &#125;ul &#123; list-style-type: none; margin: 0; padding: 0; overflow: hidden;/*必须*/ border: 1px solid #e7e7e7; background-color: #f3f3f3;&#125;li &#123; float: left; /*浮动到左侧*/&#125;li a &#123; display: block; /* 整个区域都可以被鼠标触发*/ color: #666; text-align: center; /* 让a元素水平居中*/ padding: 14px 16px; /*垂直居中定位*/ text-decoration: none;&#125;li a:hover:not(.active) &#123; background-color: #ddd; /* 利用hover为鼠标悬浮提供样式*/&#125;li a.active &#123; color: white; background-color: #4CAF50;&#125;div&#123;position:absolute;top:0;right:10px;padding: 14px 16px; /*垂直居中*/font-size:15px;&#125;span&#123;cursor:pointer;&#125;span:hover&#123;color:red; /* 利用hover为鼠标悬浮提供样式*/&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt;&lt;ul&gt; &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;#home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#news&quot;&gt;News&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;span&gt;登陆&lt;/span&gt;&lt;/div&gt;&lt;/header&gt;&lt;/body&gt;&lt;/html&gt; 这个例子大多参考 w3c 文档的教程，只是其中一种方法，具体在实际练习过程中的方式多种多样。 总结写 CSS 简单，但写好了不简单。元素属性的设置和相互影响一不留心就可能需要调试，假如对基本概念熟悉的话不但写起来思路清晰容易上手，就算出错了也可以很快定位到问题所在，路漫漫要写出好的代码还得继续修炼。另外，属性的书写顺序也要值得注意并且养成习惯： 应按功能进行分组，并以 Formatting Model（布局方式、位置） &gt; Box Model（尺寸） &gt; Typographic（文本相关） &gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性。解释：Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等Box Model 相关属性包括：border / margin / padding / width / height 等Typographic 相关属性包括：font / line-height / text-align / word-wrap 等Visual 相关属性包括：background / color / transition / list-style 等 参考文章W3C中文文档CSS Navigation Bar三栏网页宽度自适应布局方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS 实现居中完全指南 （ 翻译 ）]]></title>
      <url>%2F2016%2F12%2F12%2Ftitle-%20CSS%20%E5%B1%85%E4%B8%AD%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89%2F</url>
      <content type="text"><![CDATA[摘要文章完整了讨论了 CSS 居中的各种情况。因为文章不是很难就做了一下翻译，由于自己英文水平并不在行，有可能出现错误，所以可以点击 这条链接 前往原文 Centering in CSS: A Complete Guide 。本文仅仅做了一些概念性的添加。 正文引CSS 实现居中是个特别的让人头疼的问题，以至于让我们常问：为什么实现居中是如此困难？然而，事实上并非如此困难。只是在不同的情况下，我们需要依据不同的情境去解决问题，这让我们难以抉择。所以让我们来做一个决策树，让来选择变的更简单。 那么问题来了：I need to center… 水平方向是否是行内元素或者类行类元素（例如文本和链接 ）？在块级父容器中，我们仅仅使用 text-align:center;就可以让行内元素居中：123.center-children &#123; text-align: center;&#125; 这种方法可以让 inline, inline-block, inline-table, inline-flex等元素实现水平居中。 text-align 属性规定元素中的文本的水平对齐方式。该属性通过指定行框与哪个点对齐，从而设置块级元素内文本的水平对齐方式。 是否是块级元素？要让块级元素居中，你可以给它设置 margin-left 和 margin-right 为 auto ，不过这样做的前提是已经为元素设置了宽度，否则它将拉伸成为父容器的宽度而不需要居中了。常用的方法如下：123.center-me &#123; margin: 0 auto;&#125; 无论块级元素和父容器的宽度如何变化都不会影响到元素的居中效果。 是否要让多个块元素水平居中？假如你要让多个块元素在同一水平线上居中，给它们设置 display 类型可能是个更好的选择，这里有两个例子，分别是利用 inline-block 和 flexbox123456789101112/* inline-block */.inline-block-center &#123; text-align: center;&#125;.inline-block-center div &#123; display: inline-block;/* flexbox */.flex-center &#123; display: flex; justify-content: center;&#125; 垂直方向垂直居中需要一点点技巧 是否是行内元素或者类行类元素（例如文本和链接 ）？ 在单行的情况下 一些情况下行内元素看起来垂直居中，仅仅是使它们的上内边距和下内边距相等： 1234.link &#123; padding-top: 30px; padding-bottom: 30px;&#125; 如果由于某种情况而不能使用内边距，且我们知道文本不会换行的情况下，可以通过让行高等于高的这种方式实现垂直居中： 12345.center-text-trick &#123; height: 100px; line-height: 100px; white-space: nowrap;&#125; 在多行的情况下我们同样可以采用让上内边距和下内边距相等来实现多行文本的垂直居中，当这种办法失效的时候，我们可以给多行文本设置一个如 td 和 tr 那样的元素中，然后使用 vertical-align 来实现垂直居中： 12345678910111213141516.center-table &#123; display: table; height: 250px; background: white; width: 240px; margin: 20px;&#125;.center-table p &#123; display: table-cell; margin: 0; background: black; color: white; padding: 20px; border: 10px solid white; vertical-align: middle;&#125; 此外，当你觉得这种方式不好你可以尝试使用 flex 布局123456.flex-center-vertically &#123; display: flex; justify-content: center; flex-direction: column; height: 400px;&#125; 注意：在上面的方案中 只有父元素有高度（ 例如 px，% 等等）的时候，垂直居中才会生效。如果上述方法都不起作用，那么你就需要使用被称为幽灵元素（ghost element）的非常规解决方式：在垂直居中的元素上添加伪元素，设置伪元素的高等于父级容器的高，然后为文本添加 vertical-align: center; 样式，即可实现垂直居中。1234567891011121314.ghost-center &#123; position: relative;&#125;.ghost-center::before &#123; content: &quot; &quot;; display: inline-block; height: 100%; width: 1%; vertical-align: middle;&#125;.ghost-center p &#123; display: inline-block; vertical-align: middle;&#125; 是否是块级元素？ 是否知道块级元素的高？在网页布局中，很多情况下我们常常不知道元素的高度，例如当宽度改变时，文本的重新编排会改变高度。不同数量或样式的文本的设置都会改变高度，有时候图片也可能随之变化等等。但是，假如我们知道元素的高度，可以这样使之垂直居中： 123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px; /* account for padding and border if not using box-sizing: border-box; */&#125; 不知道元素的高？如果我们不知道元素的高度，通过把元素定位到中心然后利用 transform 让元素负方向移动一半： 12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 使用 flexbox 12345.parent &#123; display: flex; flex-direction: column; justify-content: center;&#125; 水平垂直同时居中在宽高固定情况下设定父级容器为相对定位的容器，设定子元素绝对定位的位置 position: absolute; top: 50%; left: 50%，最后使用负外边距值等于宽高的一半来实现垂直居中：123456789101112131415.parent &#123; position: relative;&#125;.child &#123; width: 300px; height: 100px; padding: 20px; position: absolute; top: 50%; left: 50%; margin: -70px 0 0 -170px;&#125; 在不知道宽高的情况下可以采用类似上面块级元素垂直居中的方式：123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; flexbox要实现水平垂直同时剧中，需使用两条居中属性：12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; 总结补充在宽高已知的情况下，要实现水平垂直方向上的居中也可以采用这样的方式：1234567891011121314.parent &#123; position: relative;&#125;.child &#123; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; width: 400px; height: 200px; background-color: #ccc; &#125; 你完全可以利用 CSS 让任何元素居中。 原文原文作者：CHRIS COYIER原文链接：Centering in CSS: A Complete Guide]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[表单对齐的两种方式]]></title>
      <url>%2F2016%2F12%2F11%2Ftitle-%20%E8%A1%A8%E5%8D%95%E5%AF%B9%E9%BD%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[摘要文章探讨了两种简单的表单对齐方式，一种是在有固定宽度的情况下，另一种是 width 为 100% 的情况下，核心都是通过给 label 元素设定宽度，再利用 text-align 来达到对齐效果，需要注意的是 input 输入框下的说明文字与 input 框的对齐。 正文固定宽度的表单首先我们利用表单元素来写一个简易的表单，代码如下：12345678910111213141516171819&lt;form action=&quot;&quot; method=&quot;&quot;&gt; &lt;div&gt; &lt;label for=&quot;name&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;mail&quot;&gt;E-mail:&lt;/label&gt; &lt;input type=&quot;email&quot; id=&quot;mail&quot; /&gt; &lt;p class=&quot;tips&quot;&gt;填上你的邮箱地址&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;msg&quot;&gt;Message:&lt;/label&gt; &lt;textarea id=&quot;msg&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;button&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Send your message&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 然后在给其添加 CSS ：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061form &#123; margin: 0 auto; width: 400px; padding: 1em; border: 1px solid #ccc; border-radius: 1em;&#125;form div+div &#123; margin-top: 1em;&#125;label &#123; /* 重要代码 */ display: inline-block; width: 90px; text-align: right;&#125;form p &#123; /* 这个额外的外边距大致充当了label和说明文字的间距 */ margin-left: .5em;&#125;form .tips &#123; font-size: 12px; color: #888; /* 将说明文字置于和文本框相同的位置 */ padding-left: 90px;&#125;input,textarea &#123; font: 1em sans-serif; width: 300px; -moz-box-sizing: border-box; box-sizing: border-box; border: 1px solid #999;&#125;input:focus,textarea:focus &#123; border-color: #000;&#125;textarea &#123; vertical-align: top; height: 5em; resize: vertical;&#125;.button &#123; /* 将按钮置于和文本框相同的位置 */ padding-left: 90px; /* 和label元素一样大小 */&#125;button &#123; /* 这个额外的外边距大致充当了label和对应文本框间的间距 */ margin-left: .5em;&#125; 效果如图所示： width 为 100% 的表单首先我们利用表单元素来写一个简易的表单，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;form&gt; &lt;div class=""&gt; &lt;label class="tips" for="email"&gt;请输入这个邮箱地址：&lt;/label&gt; &lt;input type="text" name="emailss" id="email"&gt; &lt;p&gt;邮箱地址请按要求格式输入&lt;/p&gt; &lt;/div&gt; &lt;/form&gt; &lt;form&gt; &lt;div class=""&gt; &lt;label class="tips" for="pw1"&gt;请输入密码：&lt;/label&gt; &lt;input type="password" name="pwd1"&gt; &lt;/div&gt; &lt;div class=""&gt; &lt;label class="tips" for="pw1"&gt;请重复输入密码：&lt;/label&gt; &lt;input type="password" name="pwd1"&gt; &lt;p&gt;密码请为6-16位英文数字&lt;/p&gt; &lt;/div&gt; &lt;/form&gt; &lt;form action="" method="post"&gt; &lt;div class=""&gt; &lt;label class="tips"&gt;性别：&lt;/label&gt; &lt;input type="radio" checked="checked" name="Sex" value="male" /&gt;男 &lt;input type="radio" name="Sex" value="female" /&gt;女 &lt;/div&gt; &lt;div class=""&gt; &lt;label class="tips"&gt;城市：&lt;/label&gt; &lt;select name=""&gt; &lt;option value="北京" selected="selected"&gt;北京&lt;/option&gt; &lt;option value="上海"&gt;上海&lt;/option&gt; &lt;option value="西安"&gt;西安&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=""&gt; &lt;label class="tips"&gt;爱好：&lt;/label&gt; &lt;input type="checkbox" name="checkbox1" value="checkbox"&gt;运动 &lt;input type="checkbox" name="checkbox2" value="checkbox"&gt;艺术 &lt;input type="checkbox" name="checkbox3" value="checkbox"&gt;科学 &lt;/div&gt; &lt;div class=""&gt; &lt;label class="tips"&gt;个人描述：&lt;/label&gt; &lt;textarea name="des" cols="30" rows="2"&gt;这是一个多行输入框，输入你的个人描述&lt;/textarea&gt; &lt;input type="submit" value="submit" class="submitButton" /&gt; &lt;/div&gt; &lt;/form&gt; 然后在给其添加 CSS ：123456789101112131415161718192021222324252627282930313233343536373839aside form div &#123; font-size: 14px; margin: 15px 0;&#125;aside form div .tips &#123; /* 设置label的宽度，让label浮动，右对齐，设置的padding-right的大小和下面提示文字的padding-left相等 */ float: left; text-align: right; width: 35%; padding-right: 15px;&#125;aside form div p &#123; /* margin-left与label标签的宽度一样，设置的padding-left的大小和上面label的padding-right相等 */ margin-left: 35%; padding-left: 15px; font-size: 12px; color: #aaa;&#125;aside textarea &#123; width: 50%; height: 100px;&#125;aside .submitButton &#123; width: 100%; height: 40px; border: none; border-radius: 10px; color: white; background-color: #128fdc; font-size: 20px;&#125;aside .submitButton:hover &#123; background: #0063dc;&#125; 效果如图所示： 注意 HTML 表单支持不少伪类，用以表现各元素的状态。比如，我们可以在组件被激活时作突出显示，这样可以方便用户知道表单填到哪一。 HTML5 拥有多个新的表单输入类型。这些新特性提供了更好的输入控制和验证。比如 placeholder 属性。placeholder 属性提供一种提示（hint），描述输入域所期待的值。 总结 首先是要让 label 对齐。方法一种使用 display 让 label 变成行内块级元素，设置宽度后，利用 text-align 右对齐；方法二使用 float 让 label 浮动 再设置宽度，然后右对齐。 其次需要注意的 input 下的说明文字需要和输入框对齐。都是利用 label 的宽度 和 padding 、margin值来得出说明文字 P 的 margin-left 和 padiing-left。 参考文章 HTML 表单 HTML表单指南—第一个HTML表单]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于 Atom 的插件和主题无法安装的问题]]></title>
      <url>%2F2016%2F12%2F08%2Ftitle-%20%E5%85%B3%E4%BA%8E%20Atom%20%E7%9A%84%E6%8F%92%E4%BB%B6%E5%92%8C%E4%B8%BB%E9%A2%98%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[摘要关于Atom 的插件和主题安装无法在设置中下载和安装的解决办法。 正文今天折腾了一下 Atom ，这个 Github 官方出品的编辑器的发展势头相当迅猛。不过在安装使用过程中却遇到了很多问题。Atom的安装比较简单，默认一键安装在 C 盘。官方有修改安装路径的教程，不过我并没有使用。在Atom的主题和插件安装上遇到了麻烦，就是在 Setting 中无法安装这个问题。 Atom 中文社区给出了以下解决方案： 给 apm 绑代理，可以直接使用 socks 代理 使用 proxychains-ng445 绑 socks 代理，然后 用 apm 命令安装 atom 插件 或者试试国内 npm 源 使用 VPN 不管可能是由于我个人原因或网路问题。即无法通过 apm 下载插件，也没办法在设置中下载，即使是在挂了 VPN 或使用了sock代理的情况下也无法安装和下载。只能退而求其次手动下载，多次的安装是相当的麻烦。 下面给出手动下载的解决办法： 找到 Atom 的 package 文件夹，这个是放置 Atom 插件和主题的地方，可以直接在 C 盘中寻找，一般在C:\Users\XXXX\.atom\packages这个路径之下，或者在 Atom 的 setting 页面中点击 open config folder 进入到 Atom 的配置项目，然后我们转到该项目下的 Windows 窗口进入 package 文件夹。 在 Atom 的官方插件主题网站中浏览或者查找自己所需要的插件和主题。 找到插件的 Github 地址，并复制备用。 在 packages 文件夹中运行 Git Bash，并依次输入以下命令： 123git clone https://github.com/emmetio/emmet-atom （以emmet-atom为例，将插件的源代码克隆到文件夹中）cd emmet-atom （进入插件包文件夹）npm install （生成插件） 重启 Atom，安装完成。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 Github Pages 和 Hexo 搭建个人独立博客（Win 10环境下）]]></title>
      <url>%2F2016%2F12%2F06%2Ftitle-%20%E4%BD%BF%E7%94%A8%20Github%20Pages%20%E5%92%8C%20Hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%EF%BC%88Win%2010%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%89%2F</url>
      <content type="text"><![CDATA[摘要这是一篇使用 Github Pages 和 Hexo 来搭建个人博客的笔记，记录了搭建博客的过程与其中遇到的问题。其中主要包括了以下几个部分：如何配置和使用 Hexo 框架，如何将配置好的 Hexo 部署到 Github项目中，如何绑定域名，以及 Hexo 简单优化和常用命令。 正文一、Hexo 的配置和使用1、Hexo 是什么？Hexo 是一款简洁、快速且高效的博客框架，可以在很短的时间内利用主题生成静态网页。 2、Hexo 安装前提Hexo 的安装非常简单，在 Hexo 安装必须首先安装以下应用程序： Node.js 可以简单理解为一种 Javascript 的运行环境或者平台，可以用来做服务器，执行某些任务。 Git Git 是一种分布式版本控制工具，可以用来将远程代码仓库复制到本地，或者将本地仓库推送到远程仓库。 在相对应的网站主页下载应用程序，然后安装即可。Windows 系统安装相对应的版本。 Node.js 点我前往下载页面 Git 点我前往下载页面 下载完成后鼠标点击右键选择 Git Bash Here 就可以打开 Git 打开后如下图所示： 3、Hexo 的安装和配置桌面点击鼠标右键，选择 Git Bash Here，输入 npm 命令即可安装1$ npm install -g hexo-cli 注意，如果没有 VPN 的话可能下载的速度会很慢很慢，如果出现这种状况，可以选择淘宝的 npm 源：1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完成后，在任意自己喜欢的位置创建 Hexo 文件夹，比如我的是（G:\Blog\Hexo），然后鼠标右键，选择 Git Bash Here，进入 Git 的命令框，执行以下操作：12$ hexo init$ npm install 耐心等待后，可以看到该文件夹中已经安装了 Hexo 所需要的文件 继续执行下面的命令，即可在浏览器中登陆 localhost:4000 在本地查看效果：12$ hexo generate$ hexo server 至此， Hexo 的安装已经全部结束，但仅仅在本地查看博客显然不是我们的目的，为了让别人也可以看到我们的博客，相互交流，我们需要把它发布到服务器上。而 Github Pages 可以给我们提供这个免费的服务器，省去了自己搭建服务器和数据库的麻烦。 二、将博客部署到 Github Pages 上1、Github Pages是什么？Github Pages可以被认为是用户编写的、托管在github上的静态网页。可以绑定你的域名，Github Pages可以为你提供一个免费的服务器，你可以使用它来做博客。 2、创建假如你没有 Github 账号你需要登陆主页点击 Sign Up 注册自己的账号，随后在 Github中创建一个仓库，需要注意的是仓库是有规则的，其格式必须为：yourusername.github.io。比如我的用户名为：onepiece，那么这个仓库名（Repository name）必须为：onepiece.github.io。 然后需要配置 Github 的 SSH 密钥来让本地的项目与远程的 Github建立联系，我们在本地写好代码后，可以直接通过 Git操作实现本地代码库与 Github 代码库同步。因为我个人以前下载了 Github 客户端，使用客户端进行上传或者克隆到本地，所以本机已经有密钥存在，并不需要按照下面的教程配置SSH。所以配置SSH请参考：这篇文章中的配置SSH部分，以及这篇Github添加密钥。 3、将 Hexo 部署到 Github 登陆 Github 打开自己的项目 username.github.io 点击clone or download复制地址 打开你一开始创建的Hexo文件夹（如G:\Blog\Hexo），用记事本打开刚文件夹下的_config.yml（这个是Hexo 的配置文件，以后要经常用到）文件 找到如图所示的关键词deploy，然后做出相对应的修改 在 Hexo 文件夹下执行命令1$ hexo g -d 稍等片刻后（大概不到一分钟中），就已经成功将本地的博客部署到 Github Pages 中，现在在浏览器中输入对应的地址：username.github.io就可以看到我们的博客了。 三、优化我们的博客1、主题优化Hexo主题官网 提供了很多主题供我们使用，你依照个人的喜欢预览挑选主题。我个人使用的是比较常用的一款NexT.Mist，知乎上这个问题有哪些好看的 Hexo 主题？下有答主按照star数做了个排行，你可以在其中挑选一款主题供自己使用。 首先你要进入这个主题的 Github 地址，将这个地址复制下来，比如 1https://github.com/iissnan/hexo-theme-next 然后打开 Hexo 文件夹下的 themes目录 （G:\Blog\hexo\themes），右键 Git Bash，输入命令并执行 1git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 等待下载完成。 修改配置文件，注意是 Hexo 目录下的_config.yml配置文件修改参数theme: hexo-theme-next 在 Hexo 目录中右键 Git Bash输入命令并执行。 12hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题)hexo g -d 等待片刻，然后浏览主页便可以查看相对应的效果。 更多有个性的设定，例如 设置「RSS」 添加「标签」页面 添加「分类」页面 设置「字体」 设置「代码高亮主题」 侧边栏社交链接 开启打赏功能 设置友情链接 多说评论显示 UA 腾讯公益404页面 站点建立时间 订阅微信公众号 等功能，在相应了主题主页有详细的配置说明，你可以点击进入参考设置NexT的主题配置。 2、SEO优化请参考Hexo Seo优化 四、绑定自己的域名 购买域名，个人博客不需要很顶级的域名，阿里云有很多便宜的域名可以购买。比如我自己的域名：chenyixin.win两年十块钱，所以选择你的域名然后购买就可以了。 在\hexo\source文件夹下创建文件 CNAME，用记事本打开并且添加你的域名。 注意：CNAME的意义，简单说就是别名，即将一个域名射到另一个域名。CNAME是没有后缀的，你可以用记事本创建CNAME，创建完毕后请删除后缀.txt。 然后在 Hexo 文件夹提交 1$ hexo g -d 解析域名 你可以选择阿里云的解析。打开阿里云的个人中心，点击域名，有一步解析。我选择的是DNSPOD解析需要进行如下的设置。 首先打开阿里云的个人中心，点击域名，选择管理，随后点击DNS修改/创建，修改 DNS 为：12f1g1ns2.dnspod.netf1g1ns1.dnspod.net 然后打开DNSPOD点击添加域名，将你的域名添加进去后，按照如下配置添加记录。 A记录（A record):A记录在DNS中的意义就是，域名到ip地址的转换。所以，当我们在DNS服务器中添加一个A记录时，是告诉服务器，将某个特定的域名映射到一个ip地址。这个算是最简单直白的转换规则了。 主机记录就是域名前缀，常见用法有：www：解析后的域名为 www.chenyixin.win@：直接解析主域名 chenyixin.win：泛解析，匹配其他所有域名 .chenyixin.win 等待生效就可以了，最迟要等待72个小时，但一般不会那么久，随后我们就可以通过域名来访问我们的博客了，如果你通过username.github.io最终也将映射到我们的域名上。 总结此时，使用 Hexo 和 Github Pages 搭建博客就已经告一段落了。接下来，我们可以通过其他的配置来优化我们的博客，或者已经可以开始发布文章了。我在整个搭建博客的过程中，遇到的最大问题首先是下载，没挂VPN下载 Hexo极其的慢，一度然我怀疑人生。但其他的流程很胜利，庆幸没有遇到什么bug。第二个问题是域名解析，当时，心态太着急，基础知识也不够，按照教程绑定了 Github Pages 但就是无法解析成功，后来才发现是因为我的CNAME文件上传的时候带了后缀名。可见基础常识的重要性，如果不是计算机专业的，很可能会犯一些意想之外的问题。另外，简书和谷歌上有很多教程给我提供了很大的帮助，官方文档的阅读也很有用。如果文中有什么错误，烦请大家评论让我改正，有什么问题也可以留言。 参考文章 (按照参考频度排名) Github Pages和Hexo简明教程Hexo 文档NexT 主题配置从DNS到github pages自定义域名 hexo搭建的Github博客绑定域名]]></content>
    </entry>

    
  
  
</search>
