<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>速去逮一只猫</title>
  <subtitle>办法总比困难多。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenyixin.win/"/>
  <updated>2017-09-29T01:42:36.666Z</updated>
  <id>http://chenyixin.win/</id>
  
  <author>
    <name>Chen Yixin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跨域解决方案：JSONP</title>
    <link href="http://chenyixin.win/2017/09/28/title-%20%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9AJSONP/"/>
    <id>http://chenyixin.win/2017/09/28/title- 跨域解决方案：JSONP/</id>
    <published>2017-09-28T13:28:39.865Z</published>
    <updated>2017-09-29T01:42:36.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>简单演示跨域的解决方案之一：JSON及原理。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="src-属性的特性"><a href="#src-属性的特性" class="headerlink" title="src 属性的特性"></a>src 属性的特性</h3><p>一般来说，我们所谓的跨域是指，根据浏览器同源策略所限制的一类请求场景。但其实，广义的跨域包括很多情况，一个域下的文档或脚本试图请求另一个域下的资源都可以被称为跨域。比如：</p>
<ul>
<li>资源跳转： A链接、重定向、表单提交</li>
<li>资源嵌入： <link>、<script>、<img>、<frame>等dom标签，还有样式中background:url()、@font-face()等文件外链</li>
<li>脚本请求： js发起的ajax请求、dom和js对象的跨域操作等</li>
</ul>
<p>这时我们发现拥有src属性的标签一般都拥有跨域的能力。举例来说我们常用的<code>script</code>标签，我们常常用它来引入一些库：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>那么，既然src天然拥有跨域的能力，那么我们就可以利用这种特性来跨域请求。</p>
<h3 id="JSONP-的原理"><a href="#JSONP-的原理" class="headerlink" title="JSONP 的原理"></a>JSONP 的原理</h3><p>JSONP正是基于这种特性，我们只需要保证script标签加载的是合法的JS文件即可。</p>
<ul>
<li>在script标签的src属性中写入服务端HTTP的URL地址，这个URL地址中包含一个回调函数名。</li>
<li>服务器接收到请求后，把准备好的JSON数据格式的对象填充到这个函数名中去。</li>
<li>在前端提前写好这个回调函数，用来自动处理返回的数据。</li>
</ul>
<p>这样就完成了JSONP跨域，一句话来说：JSONP就是一段参数是JSON格式的JS代码。用具体的例子来演示：</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>HTML和JS部分：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第11日前瞻：中国冲击4金 博尔特再战<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>男双力争会师决赛 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>女排将死磕巴西！<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"change"</span>&gt;</span>换一组<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></div><div class="line"></div><div class="line">$(<span class="string">'.change'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">  <span class="comment">// 在script标签的src属性中写入服务端HTTP的URL地址，这个URL地址中包含一个回调函数名。</span></div><div class="line">  script.src = <span class="string">'http://127.0.0.1/getNews?callback=appendHtml'</span>;</div><div class="line">  <span class="built_in">document</span>.head.appendChild(script);</div><div class="line">  <span class="built_in">document</span>.head.removeChild(script);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 在前端提前写好这个回调函数，用来自动处理返回的数据。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendHtml</span>(<span class="params">news</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> html = <span class="string">''</span>;</div><div class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;news.length; i++)&#123;</div><div class="line">    html += <span class="string">'&lt;li&gt;'</span> + news[i] + <span class="string">'&lt;/li&gt;'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(html);</div><div class="line">  $(<span class="string">'.news'</span>).innerHTML = html;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">id</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(id);</div><div class="line">&#125;</div><div class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>服务端过程：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/getNews'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> news = [</div><div class="line">		<span class="string">"第11日前瞻：中国冲击4金 博尔特再战200米羽球"</span>,</div><div class="line">		<span class="string">"正直播柴飚/洪炜出战 男双力争会师决赛"</span>,</div><div class="line">		<span class="string">"女排将死磕巴西！郎平安排男陪练模仿对方核心"</span>,</div><div class="line">		<span class="string">"没有中国选手和巨星的110米栏 我们还看吗？"</span>,</div><div class="line">		<span class="string">"中英上演奥运金牌大战"</span>,</div><div class="line">		<span class="string">"博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多"</span>,</div><div class="line">		<span class="string">"最“出柜”奥运？同性之爱闪耀里约"</span>,</div><div class="line">		<span class="string">"下跪拜谢与洪荒之力一样 都是真情流露"</span></div><div class="line">	];</div><div class="line">	<span class="keyword">var</span> data = [];</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</div><div class="line">		<span class="keyword">var</span> index = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*news.length);</div><div class="line">		data.push(news[index]);</div><div class="line">		news.splice(index, <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">var</span> cb = req.query.callback;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(cb)&#123;</div><div class="line">    <span class="comment">// 服务器接收到请求后，把准备好的JSON数据格式的对象填充到这个函数名中去。</span></div><div class="line">		res.send(cb + <span class="string">'('</span>+ <span class="built_in">JSON</span>.stringify(data) + <span class="string">')'</span>);</div><div class="line">        <span class="built_in">console</span>.log(cb);</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		res.send(data);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>首先启动一个服务器来模拟这种情况：<br><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fjznylw061j21h50k2adb.jpg" alt=""></p>
<p>图中我们可以看到，我们浏览器的URL是 <a href="http://a.chenyixin.com:8080/，但我们">http://a.chenyixin.com:8080/，但我们</a> src 写入的请求地址是 <a href="http://b.chenyixin.com:8080/getNews?callback=appendHtml，但当我们点击换一组时，成功请求到了数据。那么我们到底请求到的是什么呢？我们直接输入">http://b.chenyixin.com:8080/getNews?callback=appendHtml，但当我们点击换一组时，成功请求到了数据。那么我们到底请求到的是什么呢？我们直接输入</a> src 的地址：</p>
<p><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fjzo1z8a8ij21ha057jrt.jpg" alt=""><br>我们接收到的是一个函数名包裹的JSON格式的数据，其实就是一个带了参数的函数名。这个函数本身是没什么作用的，但是我们提前在前端定义了这个函数，此时服务器返回这个函数名，相当于调用了我们前端提前写好的函数，这样就成功的处理了请求完成了一次JSONP跨域。我们甚至可以用file协议来访问，也没有任何问题：</p>
<p><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fjzo535aczj21h806odh1.jpg" alt=""></p>
<h3 id="JSONP-的优缺点"><a href="#JSONP-的优缺点" class="headerlink" title="JSONP 的优缺点"></a>JSONP 的优缺点</h3><ol>
<li>优点<br>它的兼容性更好，在更加古老的浏览器中都可以运行。</li>
<li>缺点<br>它只支持GET请求而不支持POST等其它类型的HTTP请求。<br>用AJAX请求JSONP时,如果如果服务器端的错误我们是不能通过AJAX原生的error属性来捕获到错误的。</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.zhihu.com/question/19966531">JSONP 的工作原理是什么？</a><br><a href="https://segmentfault.com/a/1190000011145364">前端常见跨域解决方案（全）</a></p>
</script></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;简单演示跨域的解决方案之一：JSON及原理。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="跨域" scheme="http://chenyixin.win/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>跨域解决方案</title>
    <link href="http://chenyixin.win/2017/09/25/title-%20%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://chenyixin.win/2017/09/25/title- 跨域解决方案/</id>
    <published>2017-09-25T12:31:14.493Z</published>
    <updated>2017-09-28T14:05:35.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>通过具体例子的简单演示跨域，及总结跨域产生的原因。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一个简单跨域例子"><a href="#一个简单跨域例子" class="headerlink" title="一个简单跨域例子"></a>一个简单跨域例子</h3><p>现在我们来模拟一个从后台获取数据情景，当我们点击页面上的换一组按钮时，会发送一个AJAX请求到后台获取数据，后台在处理之后返回数据。</p>
<p>HTML 部分：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第11日前瞻：中国冲击4金 博尔特再战<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>男双力争会师决赛 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>女排将死磕巴西！<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"change"</span>&gt;</span>换一组<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>JS部分：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</div><div class="line"></div><div class="line">$(<span class="string">'.change'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">      <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">      xhr.open(<span class="string">'get'</span>, <span class="string">'http://b.chenyixin.com:8080/getNews'</span>, <span class="literal">true</span>);</div><div class="line">      xhr.send();</div><div class="line">      xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</div><div class="line">          appendHtml( <span class="built_in">JSON</span>.parse(xhr.responseText) );</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendHtml</span>(<span class="params">news</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> html = <span class="string">''</span>;</div><div class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;news.length; i++)&#123;</div><div class="line">    html += <span class="string">'&lt;li&gt;'</span> + news[i] + <span class="string">'&lt;/li&gt;'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(html);</div><div class="line">  $(<span class="string">'.news'</span>).innerHTML = html;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">id</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>后台部分（这里用server-mock这个库对后台做了简单处理，可以用npm下载使用）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/getNews'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> news = [</div><div class="line">        <span class="string">"第11日前瞻：中国冲击4金 博尔特再战200米羽球"</span>,</div><div class="line">        <span class="string">"正直播柴飚/洪炜出战 男双力争会师决赛"</span>,</div><div class="line">        <span class="string">"女排将死磕巴西！郎平安排男陪练模仿对方核心"</span>,</div><div class="line">        <span class="string">"没有中国选手和巨星的110米栏 我们还看吗？"</span>,</div><div class="line">        <span class="string">"中英上演奥运金牌大战"</span>,</div><div class="line">        <span class="string">"博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多"</span>,</div><div class="line">        <span class="string">"【边界】最“出柜”奥运？同性之爱闪耀里约"</span>,</div><div class="line">        <span class="string">"【特评】下跪拜谢与洪荒之力一样 都是真情流露"</span></div><div class="line">    ];</div><div class="line">    <span class="keyword">var</span> data = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">        <span class="keyword">var</span> index = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * news.length);</div><div class="line">        data.push(news[index]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// console.log(data);</span></div><div class="line">    res.send(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>提前修改 host 文件来模拟跨域，让浏览器的地址和请求地址不同：<br><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fjz12ohlxlj212y02ya9w.jpg" alt=""><br>此时我们命令行输入<code>server start</code>模拟服务器然后在浏览器打开网站，点击换一组按钮，然后打开浏览器会发现控制台报错：<br><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fjz172pniuj21h406ggme.jpg" alt=""></p>
<blockquote>
<p>a.chenyixin.com/:1 Failed to load <a href="http://b.chenyixin.com:8080/getNews" target="_blank" rel="external">http://b.chenyixin.com:8080/getNews</a>: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘<a href="http://a.chenyixin.com:8080" target="_blank" rel="external">http://a.chenyixin.com:8080</a>‘ is therefore not allowed access.</p>
</blockquote>
<p>这就是浏览器对于跨域失败的报错提醒。</p>
<h3 id="跨域的概念"><a href="#跨域的概念" class="headerlink" title="跨域的概念"></a>跨域的概念</h3><p>从上面的例子，我们可以看到，是不是跨域主要要看这两个方面。</p>
<ul>
<li><p>我们当前页面的URL是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//例子中当前页面的URL</div><div class="line">http://a.chenyixin.com:8080/</div></pre></td></tr></table></figure>
</li>
<li><p>我们发送的请求URL是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//例子中请求的的URL</div><div class="line">http://b.chenyixin.com:8080/</div></pre></td></tr></table></figure>
</li>
</ul>
<p>当这两个地址出现不同的时候就有可能发生跨域，那么判断的标准是什么呢？</p>
<h3 id="常见的跨域场景"><a href="#常见的跨域场景" class="headerlink" title="常见的跨域场景"></a>常见的跨域场景</h3><p><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fjz1pa18oij20ms0ammy9.jpg" alt=""></p>
<h3 id="跨域的原因"><a href="#跨域的原因" class="headerlink" title="跨域的原因"></a>跨域的原因</h3><p>为什么这些情况下需要跨域呢？这是由于浏览器的同源策略所限制的。注意 <strong>这是浏览器行为</strong>。</p>
<blockquote>
<p>浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。</p>
</blockquote>
<p>同源策略限制以下几种行为：</p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 和 Js对象无法获得</li>
<li>AJAX 请求不能发送</li>
</ul>
<h3 id="跨域的解决方案"><a href="#跨域的解决方案" class="headerlink" title="跨域的解决方案"></a>跨域的解决方案</h3><p>后面会有文章来详细介绍这些解决方案。</p>
<ul>
<li>通过jsonp跨域</li>
<li>document.domain + iframe跨域</li>
<li>location.hash + iframe</li>
<li>window.name + iframe跨域</li>
<li>postMessage跨域</li>
<li>跨域资源共享（CORS）</li>
<li>nginx代理跨域</li>
<li>nodejs中间件代理跨域</li>
<li>WebSocket协议跨域</li>
</ul>
<h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><p><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="external">前端常见跨域解决方案（全）</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">浏览器同源政策及其规避方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;通过具体例子的简单演示跨域，及总结跨域产生的原因。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerl
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="跨域" scheme="http://chenyixin.win/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>「专注概念 VOL.4」字符串方法</title>
    <link href="http://chenyixin.win/2017/09/05/title-%E3%80%8C%E4%B8%93%E6%B3%A8%E6%A6%82%E5%BF%B5%20VOL.4%E3%80%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/"/>
    <id>http://chenyixin.win/2017/09/05/title-「专注概念 VOL.4」字符串方法/</id>
    <published>2017-09-05T02:29:26.066Z</published>
    <updated>2017-09-07T11:01:37.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>涉及字符串的一些基本概念和方法总结。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><p>charAt()和charCodeAt()方法可以用来访问字符串中的特定字符。两个方法都接收一个参数，即基于0的字符位置。chatAt方法会以单个字符串的形式返回指定位置的那个字符，而charCodeAt会返回那个字符的字符编码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> str = <span class="string">'hello world!'</span>;</div><div class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">1</span>));</div><div class="line"><span class="comment">// =&gt; e</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> str = <span class="string">'hello world!'</span>;</div><div class="line"><span class="built_in">console</span>.log(str.charCodeAt(<span class="number">1</span>));</div><div class="line"><span class="comment">// =&gt; 101</span></div></pre></td></tr></table></figure>
<p>利用这个方法，我们可以做一些简单的字符截取添加操作，下面是一个生成长度为n的随机字符串的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandStr</span>(<span class="params">len</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dict = <span class="string">'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>,</div><div class="line">        newStr = <span class="string">''</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;len; i++) &#123;</div><div class="line">        <span class="keyword">var</span> randomNum = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * dict.length);</div><div class="line">        newStr += dict[randomNum];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newStr;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">getRandStr(<span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandStr</span>(<span class="params">len</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dict = <span class="string">'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>,</div><div class="line">        newStr = <span class="string">''</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;len; i++) &#123;</div><div class="line">        newStr += dict.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * dict.length));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newStr;</div><div class="line">&#125;</div><div class="line">getRandStr(<span class="number">10</span>);</div></pre></td></tr></table></figure>
<h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><h4 id="concat方法"><a href="#concat方法" class="headerlink" title="concat方法"></a>concat方法</h4><p>concat()方法用于将一个或多个字符串拼接起来，一般我们用 + 操作符来拼接字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> str1 = <span class="string">'hello '</span>;</div><div class="line"><span class="keyword">var</span> str2 = str1.concat(<span class="string">'world!'</span>);</div><div class="line"><span class="built_in">console</span>.log(str2);</div><div class="line"></div><div class="line"><span class="comment">// =&gt; hello world!</span></div></pre></td></tr></table></figure>
<h4 id="slice-substr-substring-方法"><a href="#slice-substr-substring-方法" class="headerlink" title="slice substr substring 方法"></a>slice substr substring 方法</h4><p>这三个方法都是基于子字符串创建新字符串的方法，都会返回被操作字符串的一个子字符串。</p>
<ul>
<li>slice方法接收二个参数，第一个是指定子字符串的开始位置，第二个是指定子字符串最后一个字符后面的位置。</li>
<li>substr方法接收二个参数，第一个指定子字符串的开始位置，第二个参数则是返回的字符个数。</li>
<li>substring方法接收二个参数，第一个指定子字符串的开始位置，第二个是指定子字符串最后一个字符后面的位置。</li>
</ul>
<h3 id="字符串的位置方法"><a href="#字符串的位置方法" class="headerlink" title="字符串的位置方法"></a>字符串的位置方法</h3><p>indexOf 和 lastIndexOf 用来查找子字符串的位置，他们接收一个子字符串作为参数，然后返回改字符串的位置，如果没有则返回-1。第二个参数，表示从字符串中那个位置开始搜索。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'who are you?'</span></div><div class="line"><span class="keyword">var</span> num = str.indexOf(<span class="string">'a'</span>);</div><div class="line"><span class="built_in">console</span>.log(num);</div><div class="line"><span class="comment">// =&gt; 4</span></div></pre></td></tr></table></figure>
<h3 id="trim方法"><a href="#trim方法" class="headerlink" title="trim方法"></a>trim方法</h3><p>trim 方法会创建一个字符串的副本，删除字符串前后的空格。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'  hello world!  '</span></div><div class="line"><span class="keyword">var</span> newStr = str.trim();</div><div class="line">newStr</div><div class="line"><span class="comment">// "hello world!"</span></div><div class="line">str</div><div class="line"><span class="comment">// "  hello world!  "</span></div></pre></td></tr></table></figure>
<h3 id="大小写转化方法"><a href="#大小写转化方法" class="headerlink" title="大小写转化方法"></a>大小写转化方法</h3><p>toLowerCase 和 toUpperCase方法用于转化大小写，下面是一个首字母大写的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ucFirst</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="string">''</span>;</div><div class="line">    <span class="keyword">if</span> ( !str || <span class="keyword">typeof</span> str !== <span class="string">'string'</span>) &#123;</div><div class="line">        alert(<span class="string">'请输入字符串'</span>);</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    result = str.charAt(<span class="number">0</span>).toUpperCase() + str.slice(<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> result;    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</div><div class="line">ucFirst(str);</div><div class="line"></div><div class="line"><span class="comment">// "Hello"</span></div></pre></td></tr></table></figure>
<h3 id="匹配方法"><a href="#匹配方法" class="headerlink" title="匹配方法"></a>匹配方法</h3><h4 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h4><p>match方法用于确定原字符串是否匹配某个子字符串,只接受一个参数即一个正则表达式或者一个RegExp对象，返回一个数组。如果没有找到匹配，则返回null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = <span class="string">'cat bat dat eat'</span></div><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/.at/g</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> matches = test.match(reg);</div><div class="line">matches</div><div class="line"><span class="comment">// ["cat", "bat", "dat", "eat"]</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/ba./g</span>;</div><div class="line"><span class="keyword">var</span> matches1 = test.match(reg1)</div><div class="line">matches1</div><div class="line"><span class="comment">// ["bat"]</span></div><div class="line"></div><div class="line"><span class="comment">// 返回数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> matches2 = test.match(<span class="string">'cat'</span>);</div><div class="line">matches2.index;</div><div class="line"><span class="comment">// =&gt;  0</span></div><div class="line">matches2.input;</div><div class="line"><span class="comment">// "cat bat dat eat"</span></div></pre></td></tr></table></figure>
<h4 id="search方法"><a href="#search方法" class="headerlink" title="search方法"></a>search方法</h4><p>search方法类似于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</p>
<h4 id="replace方法"><a href="#replace方法" class="headerlink" title="replace方法"></a>replace方法</h4><p>replace方法用于替换匹配的子字符串。只替换第一个匹配的，假如利用带修饰符g的正则可以替换全部。一个高程中的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = <span class="string">'cat bat dat eat'</span></div><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/at/g</span>;</div><div class="line"><span class="keyword">var</span> result = test.replace(reg,<span class="string">'ond'</span>);</div><div class="line">result;</div><div class="line"><span class="comment">// "cond bond dond eond"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> result1 = test.replace(<span class="string">'at'</span>,<span class="string">'ond'</span>);</div><div class="line">result1;</div><div class="line"><span class="comment">// "cond bat dat eat"</span></div></pre></td></tr></table></figure>
<h4 id="split方法"><a href="#split方法" class="headerlink" title="split方法"></a>split方法</h4><p>split方法可以基于指定的分隔符将字符串分割成多个子字符串并放入一个数组中，接收的参数可以是一个字符串也可以是正则表达式。<strong>split可以接收第二个参数，指定返回数组的大小</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'a,b,c,d,e,f,g'</span>;</div><div class="line"><span class="keyword">var</span> result = str.split(<span class="string">','</span>);</div><div class="line">result;</div><div class="line"><span class="comment">// =&gt; ["a", "b", "c", "d", "e", "f", "g"]</span></div><div class="line"><span class="keyword">var</span> result1 = str.split(<span class="string">','</span>,<span class="number">2</span>);</div><div class="line">result1;</div><div class="line"><span class="comment">// =&gt; ["a", "b"]</span></div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="external">JavaScript 高级程序设计</a><br><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="external">JavaScript 标准参考教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;涉及字符串的一些基本概念和方法总结。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="JavaScript" scheme="http://chenyixin.win/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>「专注概念 VOL.3」数组方法</title>
    <link href="http://chenyixin.win/2017/08/31/title-%20%E3%80%8C%E4%B8%93%E6%B3%A8%E6%A6%82%E5%BF%B5%20VOL.3%E3%80%8D%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <id>http://chenyixin.win/2017/08/31/title- 「专注概念 VOL.3」数组方法/</id>
    <published>2017-08-31T09:43:31.075Z</published>
    <updated>2017-09-07T10:58:34.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>数组类型的一些基本概念和方法总结。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>Array.isArray方法用来判断一个值是否为数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="built_in">Array</span>.isArray(arr);</div><div class="line"><span class="comment">// =&gt; true</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</div><div class="line">    <span class="comment">// 执行某种操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="转化方法"><a href="#转化方法" class="headerlink" title="转化方法"></a>转化方法</h3><p>valueOf方法返回数组本身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.valueOf();</div><div class="line"><span class="comment">// =&gt; [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<p>toString方法会返回由数组中的每个值的字符串形式拼接而成的一个以逗号分隔的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.toString();</div><div class="line"><span class="comment">// =&gt; "1,2,3,4,5"</span></div></pre></td></tr></table></figure>
<p>join方法以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.join(<span class="string">'|'</span>);</div><div class="line"><span class="comment">// =&gt; "1|2|3|4|5"</span></div></pre></td></tr></table></figure>
<p>数组的转化方法常常与字符串的方法结合起来使用，下面是一个判断字符串是否是回文的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> ( !str || <span class="keyword">typeof</span> str !== <span class="string">'string'</span>) &#123;</div><div class="line">        alert(<span class="string">'请输入字符串'</span>);</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> reverseStr = str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</div><div class="line">    <span class="keyword">if</span> ( reverseStr === str) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'true'</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'false'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o1 = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> o2 = <span class="string">'heeeeee'</span>;</div><div class="line"><span class="keyword">var</span> o3 = <span class="string">'zxccxz'</span>;</div><div class="line"></div><div class="line">isPalindrome(o1);</div><div class="line"><span class="comment">// = &gt; alert 请输入字符串</span></div><div class="line">isPalindrome(o2);</div><div class="line"><span class="comment">// =&gt; flase</span></div><div class="line">isPalindrome(o3);</div><div class="line"><span class="comment">// =&gt; true;</span></div></pre></td></tr></table></figure>
<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>栈是一种遵循后进先出原则 LIFO 的数据结构。新添加的或者待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底，换句话说，最新添加的元素最先被溢出，而栈中项的推入和弹出都只发生在栈顶。JavaScript 中提供 push 和 pop 方法来实现类似栈的行为。</p>
<p>push 方法可以接收任意数量的参数，把它们添加到数组末尾，并返回修改后数组的长度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.push(<span class="number">6</span>,<span class="number">7</span>)</div><div class="line"><span class="comment">// 7</span></div><div class="line">arr</div><div class="line"><span class="comment">//  =&gt; [1, 2, 3, 4, 5, 6, 7]</span></div></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/mw690/75fcfef2ly1fj36hkby2zj20xo0bsjry.jpg" alt=""></p>
<p>pop 方法则从数组的末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.pop();</div><div class="line"><span class="comment">// 5</span></div><div class="line">arr</div><div class="line"><span class="comment">//  =&gt; [1, 2, 3, 4]</span></div></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/mw690/75fcfef2ly1fj36huq5rlj210i0c1q3b.jpg" alt=""></p>
<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>队列是一种遵循先进先出原则 FIFO 的数据结构，队列在尾部添加新元素，并从顶部移除元素，现实中排队就是一个队列例子，先来的先服务。</p>
<p>shift 方法能够移除数组中的第一个项并且返回该项，同时将数组长度减1，shift 和 push 方法可以象使用队列一样使用数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.shift();</div><div class="line"><span class="comment">// 1</span></div><div class="line">arr</div><div class="line"><span class="comment">// =&gt; [2, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<p>JavaScript 还提供了一个 unshift 方法可以在数组的前端添加任意数量的项并且返回新数组的长度。unshift 和 pop 方法可以模拟从相反的方向模拟队列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.unshift(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</div><div class="line"><span class="comment">// 8</span></div><div class="line">arr</div><div class="line"><span class="comment">// =&gt; [6, 7, 8, 1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat 方法"></a>concat 方法</h4><p>concat 方法可以基于当前的数组来创建一个新的数组，它可以接收值或着数组，假如是单纯的字符串或数值，concat会将它们简单的添加到结果数组的末尾，假如传递的是数组，则会把数组中的每一项都添加到结果数组中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> newArr = arr.concat(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>])</div><div class="line">newArr</div><div class="line"><span class="comment">// =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></div><div class="line">arr</div><div class="line"><span class="comment">// =&gt; [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<p>一个将多维数组转化为一维数组的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ret = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr[i])) &#123;</div><div class="line">            ret = ret.concat(flatten(arr[i]));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ret.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">flatten([[[[[<span class="number">0</span>]], [<span class="number">1</span>]], [[[<span class="number">2</span>], [<span class="number">3</span>]]], [[<span class="number">4</span>], [<span class="number">5</span>]]]]) <span class="comment">// [0, 1, 2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">ary</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> ary.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(b)) &#123;</div><div class="line">      <span class="keyword">return</span> a.concat(flatten(b))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> a.concat(b)</div><div class="line">  &#125;, [])</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">ary</span>) =&gt;</span> ary.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.concat(<span class="built_in">Array</span>.isArray(b) ? flatten(b) : b), [])</div></pre></td></tr></table></figure></p>
<h4 id="slice-方法"><a href="#slice-方法" class="headerlink" title="slice 方法"></a>slice 方法</h4><p>slice 方法可以基于当前数组的一项或多项创建一个新数组。它接收一个或两个参数即返回项的起始位置和结束位置。该方法也不会影响原来的数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> arr1 = arr.slice(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> arr2 = arr.slice(<span class="number">1</span>);</div><div class="line">arr1</div><div class="line"><span class="comment">// =&gt; [2]</span></div><div class="line">arr2</div><div class="line"><span class="comment">// =&gt; [2, 3, 4, 5]</span></div><div class="line">arr</div><div class="line"><span class="comment">// =&gt; [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure></p>
<h4 id="最强方法-splice"><a href="#最强方法-splice" class="headerlink" title="最强方法 splice"></a>最强方法 splice</h4><p>splice 是数组中最强大的方法，它有三个用途：</p>
<ul>
<li>删除：可以删除任意数量的项。指定2个参数，要删除的第一项的位置和要删除的项数。</li>
<li>插入：向指定位置插入任意数量的项。指定3个参数，起始位置，0（要删除的项数为0），要插入的项。</li>
<li>替换：在指定位置替换任意数量的项。指定3个参数，起始位置，要删除的项数，要插入的任意数量的项。<br><strong>注意1：splice方法始终会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项则返回一个空数组。</strong><br><strong>注意2：当我们要用splice和for循环来过滤数组时，注意每次循环数组的长度都会发现变化，看下面的例子：</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">2</span>,<span class="number">-5</span>]</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length<span class="number">-1</span>;</div><div class="line">    <span class="comment">// 从后往前可以避免这个问题</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = len; i&gt;<span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">if</span> (arr[i] &lt;= <span class="number">0</span>) &#123;</div><div class="line">            arr.splice(i,<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">filter(arr);</div><div class="line"><span class="built_in">console</span>.log(arr);</div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterPositive</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> newArr= [];</div><div class="line">    newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">typeof</span> item === <span class="string">'number'</span> &amp;&amp; item &gt;<span class="number">0</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> newArr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">-1</span>,  <span class="number">2</span>,  <span class="string">'哈哈'</span>, <span class="literal">true</span>];</div><div class="line"><span class="keyword">var</span> newArr = filterPositive(arr);</div><div class="line"><span class="built_in">console</span>.log(newArr) ;</div><div class="line"><span class="comment">// =&gt; [3, 2]</span></div><div class="line"><span class="built_in">console</span>.log(arr);</div><div class="line"><span class="comment">// =&gt; [3, -1, 2, "哈哈", true]</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>我们可以用splice 来模拟栈方法和队列方法：</p>
<p>模拟push<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">methodPush</span>(<span class="params">arr,item</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(methodPush.length !==<span class="built_in">arguments</span> &amp;&amp; <span class="built_in">arguments</span>.length &gt;<span class="number">2</span> )&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length<span class="number">-1</span>;i++)&#123;</div><div class="line">            arr.splice(arr.length,<span class="number">0</span>,<span class="built_in">arguments</span>[i+<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> arr.length;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length ===<span class="number">2</span>)&#123;</div><div class="line">        arr.splice(arr.length,<span class="number">0</span>,item);</div><div class="line">        <span class="keyword">return</span> arr.length;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> arr.length;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>];</div><div class="line">methodPush(arr1,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>);</div><div class="line"><span class="comment">//9</span></div><div class="line">arr1</div><div class="line"><span class="comment">// [1, 2, 2, 3, 5, 2, 6, 8, 5]</span></div></pre></td></tr></table></figure></p>
<p>模拟pop<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">methodPop</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.splice(arr.length<span class="number">-1</span>,<span class="number">1</span>).toString();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>];</div><div class="line">methodPop(arr2);</div><div class="line"><span class="comment">//"5"</span></div></pre></td></tr></table></figure></p>
<p>模拟shift<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">methodShift</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.splice(<span class="number">0</span>,<span class="number">1</span>).toString();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>];</div><div class="line">methodShift(arr3);</div><div class="line"><span class="comment">// "1"</span></div></pre></td></tr></table></figure></p>
<p>模拟unshift<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">methodUnshift</span>(<span class="params">arr,item</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>( methodUnshift.length !==<span class="built_in">arguments</span> &amp;&amp; <span class="built_in">arguments</span>.length &gt;<span class="number">2</span> )&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length<span class="number">-1</span>;i++)&#123;</div><div class="line">            arr.splice(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">arguments</span>[i+<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> arr.length;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">2</span>)&#123;</div><div class="line">        arr.splice(<span class="number">0</span>,<span class="number">0</span>,item);</div><div class="line">        <span class="keyword">return</span> arr.length;</div><div class="line">    &#125; <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> arr.length;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr4 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>];</div><div class="line">methodUnshift(arr4,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">2</span>,<span class="number">1</span>);</div><div class="line"><span class="comment">//10</span></div><div class="line">arr4</div><div class="line"><span class="comment">//[1, 2, 45, 3, 2, 1, 3, 2, 3, 5]</span></div></pre></td></tr></table></figure></p>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>sort可以接收一个比较函数做参数，下面是一个对于数值类型排序的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> a - b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">arr = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">1</span>];</div><div class="line">arr.sort(compare);</div><div class="line"></div><div class="line"><span class="comment">// =&gt; [1, 1, 2, 4, 6, 6, 12]</span></div></pre></td></tr></table></figure>
<p>对对象排序<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortByProperty</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sortFunction = <span class="function"><span class="keyword">function</span>(<span class="params">obj1,obj2</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (obj1[propertyName] &gt; obj2[propertyName] ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (obj1[propertyName] == obj2[propertyName]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sortFunction;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'chen'</span>,<span class="number">20</span>);</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'yi'</span>,<span class="number">60</span>);</div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> Person(<span class="string">'xin'</span>,<span class="number">100</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> arrp = [p13,p1,p2];</div><div class="line">arrp.sort(sortByProperty(<span class="string">'age'</span>));</div></pre></td></tr></table></figure></p>
<p><img src="http://ww1.sinaimg.cn/mw690/75fcfef2ly1fj37n1rutfj20x00cbq3r.jpg" alt=""></p>
<p>reverse 方法将反转数组的顺序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">arr = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">1</span>];</div><div class="line">arr.reverse();</div><div class="line">arr</div><div class="line"><span class="comment">// =&gt; [1, 6, 12, 6, 4, 1, 2]</span></div></pre></td></tr></table></figure>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><ul>
<li>every() 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true 则返回 true。</li>
<li>some() 对数组中的每一项运行给定函数，如果该函数中任一项返回 true 则返回 true。</li>
<li>filter() 对数组中每一项运行给定函数，返回该函数会返回 true 的项数组成的数组。</li>
<li>forEach() 对数组中的每一项都运行给定函数，这个方法没有返回值。</li>
<li>map() 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
</ul>
<h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><p>reduce() 方法会遍历数组的所有项，然后构建一个最终的返回的值。接收2个参数：一个在每一项上调用的函数和（可选）作为归并基础的初始值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="comment">// 参数函数接收4个参数，前一个值，当前值，项的索引，数组对象</span></div><div class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,cur,index,array</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> prev + cur</div><div class="line">    &#125;);</div><div class="line">sum</div><div class="line"><span class="comment">// =&gt; 15</span></div></pre></td></tr></table></figure>
<p>手写一个reduce方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">methodReduce</span>(<span class="params">arr,fn,initValue</span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> newArr = ( initValue === <span class="literal">undefined</span> ? [] : [initValue] ).concat(arr) ;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>( newArr.length &gt; <span class="number">1</span>) &#123;</div><div class="line">        newArr.splice(<span class="number">0</span>,<span class="number">2</span>, fn(newArr[<span class="number">0</span>], newArr[<span class="number">1</span>]));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> newArr[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> result = num1 + num2 ;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">methodReduce(arr,sum,<span class="number">10</span>);</div><div class="line"><span class="comment">//25</span></div></pre></td></tr></table></figure>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>indexOf() 和 lastIndexOf() 方法都接收2个参数：要查找的项和表示查找起点位置的索引。这两个方法都返回要查找的项在数组中的位置，<strong>在没有找到的情况下，返回-1</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> num = arr.indexOf(<span class="number">3</span>);</div><div class="line">num</div><div class="line"><span class="comment">// = &gt;  2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> num1 = arr.indexOf(<span class="string">'哈哈'</span>);</div><div class="line">num1</div><div class="line"><span class="comment">// = &gt; -1</span></div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="external">JavaScript 高级程序设计</a><br><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="external">JavaScript 标准参考教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;数组类型的一些基本概念和方法总结。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="JavaScript" scheme="http://chenyixin.win/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScrip 浅拷贝和深拷贝</title>
    <link href="http://chenyixin.win/2017/08/23/title-%20JavaScript%20%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://chenyixin.win/2017/08/23/title- JavaScript 浅拷贝和深拷贝/</id>
    <published>2017-08-23T13:40:15.873Z</published>
    <updated>2017-08-31T10:08:06.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>JavaScrip 中如何实现浅拷贝和深拷贝。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在 JavaScript 中对象、数组、函数等都属于引用类型，引用类型指指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象。当我们拷贝引用类型的变量时，复制的其实只是一个指针，拷贝后的对象和原来的对象指向同一块内存地址，改变其中一个，另一个也会发生变化。这种拷贝原对象的引用，即为浅拷贝。而深拷贝，会开辟一块新的内存地址，拷贝后的新对象与原对象互不影响。</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>把对象赋值给新的变量即为最简单的一种浅拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">'chen'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o2 = o1;</div><div class="line"><span class="built_in">console</span>.log(o1 === o2);</div><div class="line"><span class="comment">// true</span></div><div class="line">o2.name = <span class="string">'yan'</span>;</div><div class="line"><span class="built_in">console</span>.log(o1.name);</div><div class="line"><span class="comment">// yan</span></div></pre></td></tr></table></figure>
<p>在jQuery中我们可以调用 extend() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jQuery.extend( target [, object1 ] [, objectN ] )</div></pre></td></tr></table></figure>
<p>Object.assign() 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
<blockquote>
<p>语法：Object.assign (target目标对象, …sources) 返回值为目标对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</div><div class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</div><div class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; a: 1 &#125;</span></div></pre></td></tr></table></figure>
<p>我们也可以自己写一个简单的浅拷贝:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">oldObject</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (!oldObject || <span class="keyword">typeof</span> oldObject != <span class="string">'object'</span> ) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error arguments'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> newObject  = oldObject === <span class="built_in">Array</span> ? [] : &#123;&#125;;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> keys <span class="keyword">in</span> oldObject)&#123;</div><div class="line">        <span class="keyword">if</span>(oldObject.hasOwnProperty(keys))&#123;</div><div class="line"></div><div class="line">        newObject[keys] = oldObject[keys];</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> newObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>首先，我们依然可以使用jQuery中的exten()方法，只需要让deep参数变为 true：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jQuery.extend( [deep ], target, object1 [, objectN ] )</div><div class="line">// deep 如果是true，合并成为递归（又叫做深拷贝）。</div></pre></td></tr></table></figure></p>
<p>利用JSON对象中的parse和stringify也可以实现深拷贝，JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">   <span class="keyword">var</span> newObject = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</div><div class="line">   <span class="keyword">return</span> newObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们也可以利用递归自己写一个深拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">oldObject</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!oldObject || <span class="keyword">typeof</span> oldObject !== <span class="string">'object'</span>)&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error arguments'</span>, <span class="string">'shallowClone'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> newObject = oldObject.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> keys <span class="keyword">in</span> oldObject) &#123;</div><div class="line">        <span class="keyword">if</span> (oldObject.hasOwnProperty(keys)) &#123;</div><div class="line">            <span class="keyword">if</span>(oldObject[keys] &amp;&amp; <span class="keyword">typeof</span> oldObject[keys] === <span class="string">'object'</span>)&#123;</div><div class="line">              newObject[keys] = oldObject[keys].constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</div><div class="line">              newObject[keys] = deepCopy(oldObject[keys]);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">              newObject[keys] = oldObject[keys];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/wengjq/Blog/issues/3" target="_blank" rel="external">JavaScript中浅拷贝和深拷贝的实现</a><br><a href="https://segmentfault.com/a/1190000008637489" target="_blank" rel="external">JavaScript中的浅拷贝和深拷贝</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;JavaScrip 中如何实现浅拷贝和深拷贝。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlin
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="JavaScript" scheme="http://chenyixin.win/tags/JavaScript/"/>
    
      <category term="浅拷贝" scheme="http://chenyixin.win/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
      <category term="深拷贝" scheme="http://chenyixin.win/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 如何实现重载</title>
    <link href="http://chenyixin.win/2017/08/22/title-%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%20JavaScript%20%E9%87%8D%E8%BD%BD/"/>
    <id>http://chenyixin.win/2017/08/22/title- 如何实现 JavaScript 重载/</id>
    <published>2017-08-22T11:12:29.460Z</published>
    <updated>2017-08-31T10:05:25.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>文章主要讨论 JavaScript 中如何实现重载。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="重载的含义"><a href="#重载的含义" class="headerlink" title="重载的含义"></a>重载的含义</h3><p>重载指的是不同的函数使用相同的函数名，但函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。一个其他语言的重载例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int sum(int num1, int num2)&#123;</div><div class="line">  return num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">float sum(float num1, float num2)&#123;</div><div class="line">  return num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sum(1, 2);</div><div class="line">sum(1.5, 2.4);</div></pre></td></tr></table></figure></p>
<h3 id="JavaScript-没有重载"><a href="#JavaScript-没有重载" class="headerlink" title="JavaScript 没有重载"></a>JavaScript 没有重载</h3><p>在 JavaScript 中函数是对象的一种，因此函数名实际上是一个指向函数对象的指针，不会与函数绑定，所以 JavaScript 中没有重载，同名函数会被覆盖重写。一个来自高程的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num += <span class="number">100</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num += <span class="number">200</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>) <span class="comment">// 300</span></div></pre></td></tr></table></figure></p>
<h3 id="如何实现-JavaScript-重载"><a href="#如何实现-JavaScript-重载" class="headerlink" title="如何实现 JavaScript 重载"></a>如何实现 JavaScript 重载</h3><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>通过对函数的 arguments对象的length值进行判断，来对不同的参数进行不同的操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(<span class="built_in">arguments</span>.length)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">        <span class="comment">// do basic code</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">        <span class="comment">// do code with one</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">        <span class="comment">// do code with two</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">        <span class="comment">// do code with three</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数组和对象"><a href="#数组和对象" class="headerlink" title="数组和对象"></a>数组和对象</h4><p>也可以使用数据和对象的方式，通过数组的索引来对不同的参数进行不同的操作，原理和上面利用 arguments的length值类似。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">fooArr = [</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">// do basic code</span></div><div class="line">    &#125;,</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">        <span class="comment">// do code with one</span></div><div class="line">    &#125;,</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">        <span class="comment">// do code with two</span></div><div class="line">    &#125;</div><div class="line">]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> fooArr[<span class="built_in">arguments</span>.length](a.b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>来自 jQuery 之父 John Resig 的 JavaScript 函数重载方法。以下是一个完整示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addMethod</span>(<span class="params">object, name, fn</span>)</span>&#123;</div><div class="line"> <span class="comment">// 将前一个添加的方法保存在old中</span></div><div class="line"> <span class="keyword">var</span> old = object[name];</div><div class="line"> <span class="comment">// 重写object[name]方法</span></div><div class="line"> object[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="comment">// 假如传入的参数和预期的一致，直接调用</span></div><div class="line">     <span class="keyword">if</span> (fn.length == <span class="built_in">arguments</span>.length)&#123;</div><div class="line">         <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="comment">//否则，判断old是否为函数，如果是就直接调用            </span></div><div class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> old == <span class="string">'function'</span>)&#123;</div><div class="line">         <span class="keyword">return</span> old.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);             </div><div class="line">     &#125;</div><div class="line"> &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* 通过addMehod函数实现对find方法的重载 */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 不传参数时，返回所有name</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find0</span>(<span class="params"></span>)</span>&#123;　　</div><div class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.names;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 传一个参数时，返回firstName匹配的name</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find1</span>(<span class="params">firstName</span>)</span>&#123;　　</div><div class="line"> <span class="keyword">var</span> result = [];　　</div><div class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.names.length; i++)&#123;　　　　</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.names[i].indexOf(firstName) === <span class="number">0</span>)&#123;　　　　　　</div><div class="line">         result.push(<span class="keyword">this</span>.names[i]);　　　　</div><div class="line">     &#125;　　</div><div class="line"> &#125;　　</div><div class="line"> <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 传两个参数时，返回firstName和lastName都匹配的name</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find2</span>(<span class="params">firstName, lastName</span>)</span>&#123;　</div><div class="line"> <span class="keyword">var</span> result = [];　　</div><div class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.names.length; i++)&#123;　　　　</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.names[i] === (firstName + <span class="string">" "</span> + lastName))&#123;　　　　　　</div><div class="line">         result.push(<span class="keyword">this</span>.names[i]);　　　　</div><div class="line">     &#125;　　</div><div class="line"> &#125;　　</div><div class="line"> <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Users</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> addMethod(Users.prototype, <span class="string">"find"</span>, find0);</div><div class="line"> addMethod(Users.prototype, <span class="string">"find"</span>, find1);</div><div class="line"> addMethod(Users.prototype, <span class="string">"find"</span>, find2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> users = <span class="keyword">new</span> Users();</div><div class="line">users.names = [<span class="string">"John Resig"</span>, <span class="string">"John Russell"</span>, <span class="string">"Dean Tom"</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(users.find());</div><div class="line"><span class="comment">// 输出[ 'John Resig', 'John Russell', 'Dean Tom' ]</span></div><div class="line"><span class="built_in">console</span>.log(users.find(<span class="string">"John"</span>));</div><div class="line"><span class="comment">// 输出[ 'John Resig', 'John Russell' ]</span></div><div class="line"><span class="built_in">console</span>.log(users.find(<span class="string">"John"</span>, <span class="string">"Resig"</span>));</div><div class="line"><span class="comment">// 输出[ 'John Resig' ]</span></div><div class="line"><span class="built_in">console</span>.log(users.find(<span class="string">"John"</span>, <span class="string">"E"</span>, <span class="string">"Resig"</span>));</div></pre></td></tr></table></figure>
<h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><p><a href="https://blog.fundebug.com/2017/07/24/javascript_metho_overloading/" target="_blank" rel="external">JavaScript函数重载</a><br><a href="https://stackoverflow.com/questions/10855908/how-to-overload-functions-in-javascript" target="_blank" rel="external">How to overload functions in javascript?</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;文章主要讨论 JavaScript 中如何实现重载。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;header
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="JavaScript" scheme="http://chenyixin.win/tags/JavaScript/"/>
    
      <category term="重载" scheme="http://chenyixin.win/tags/%E9%87%8D%E8%BD%BD/"/>
    
      <category term="overload" scheme="http://chenyixin.win/tags/overload/"/>
    
  </entry>
  
  <entry>
    <title>浏览器兼容的基本方法和思路</title>
    <link href="http://chenyixin.win/2017/08/10/title-%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%9D%E8%B7%AF/"/>
    <id>http://chenyixin.win/2017/08/10/title- 浏览器兼容思路/</id>
    <published>2017-08-10T03:40:18.475Z</published>
    <updated>2017-08-31T10:05:20.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>有关浏览器兼容的思路和一些常用的工具。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>不同的浏览器有不同的标准不同的实现方式，同一个浏览器也有不同的版本不同的功能，版本越老的浏览器bug越多，在这样的差异背景下就产生了浏览器的兼容问：怎么样让同一份代码在所有的浏览器下都显示正常。</p>
<h3 id="处理浏览器兼容的基本思路"><a href="#处理浏览器兼容的基本思路" class="headerlink" title="处理浏览器兼容的基本思路"></a>处理浏览器兼容的基本思路</h3><h4 id="要不要实现"><a href="#要不要实现" class="headerlink" title="要不要实现"></a>要不要实现</h4><p>从产品的角度。考虑网站的受众是什么，受众的浏览器是什么，我们可以通过<a href="http://tongji.baidu.com/data/browser" target="_blank" rel="external">查询浏览器市场份额</a>查询所需要兼容的浏览器的份额，结合受众所使用浏览器的比例去考虑需要不要兼容。从成本的角度。某个效果的实际作用与需要实现其效果所花费的成本需要做个考量。</p>
<h4 id="确认实现程度"><a href="#确认实现程度" class="headerlink" title="确认实现程度"></a>确认实现程度</h4><p>在确定需要做兼容后，再确认不同的浏览器需要实现到什么程度。</p>
<h4 id="怎么实现"><a href="#怎么实现" class="headerlink" title="怎么实现"></a>怎么实现</h4><p>在确定实现到什么程度时，我们同时需要考虑用什么方式去实现，是渐进增强还是优雅降级。</p>
<ul>
<li>渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li>
<li>优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li>
</ul>
<p>最后我们再去考虑处理兼容问题的具体手段。</p>
<h3 id="处理兼容的具体手段"><a href="#处理兼容的具体手段" class="headerlink" title="处理兼容的具体手段"></a>处理兼容的具体手段</h3><h4 id="选对合适的框架"><a href="#选对合适的框架" class="headerlink" title="选对合适的框架"></a>选对合适的框架</h4><blockquote>
<p>Bootstrap (&gt;=ie8)<br>jQuery 1.~ (&gt;=ie6), jQuery 2.~ (&gt;=ie9)<br>Vue.js (&gt;= ie9)<br>React.js (&gt;= ie8)<br>Angluar.js 1.2 (&gt;=ie8),  Angluar.js 1.3 (&gt;=ie9) Angluar.js 2(&gt;=ie10)</p>
<h4 id="条件注释"><a href="#条件注释" class="headerlink" title="条件注释"></a>条件注释</h4><p>条件注释 (conditional comment) 是于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!--[if !IE]&gt;&lt;!--&gt; 除IE外都可识别 &lt;!--&lt;![endif]--&gt;</div><div class="line">&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt;</div></pre></td></tr></table></figure>
<h4 id="CSS-hack"><a href="#CSS-hack" class="headerlink" title="CSS hack"></a>CSS hack</h4><p>由于不同厂商的浏览器或不同版本的浏览器对CSS的解析不经相同，导致页面的渲染效果不一样，这时就需要对不同的浏览器做针对性的代码编写让不同的浏览器都能得到我们想要的效果。CSS hack大致有三种形式。</p>
<ol>
<li><p>属性前缀法(即类内部Hack)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">“-″减号是IE6专有的hack</div><div class="line">“\9″ IE6/IE7/IE8/IE9/IE10都生效</div><div class="line">“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack</div><div class="line">“\9\0″ 只对IE9/IE10生效，是IE9/10的hack</div><div class="line">firefox前述都不能认识</div></pre></td></tr></table></figure>
</li>
<li><p>选择器前缀法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*html *前缀只对IE6生效</div><div class="line">*+html *+前缀只对IE7生效</div><div class="line">@media screen\9&#123;...&#125;只对IE6/7生效</div><div class="line">@media \0screen &#123;body &#123; background: red; &#125;&#125;只对IE8有效</div><div class="line">@media \0screen\,screen\9&#123;body &#123; background: blue; &#125;&#125;只对IE6/7/8有效</div><div class="line">@media screen\0 &#123;body &#123; background: green; &#125;&#125; 只对IE8/9/10有效</div><div class="line">@media screen and (min-width:0\0) &#123;body &#123; background: gray; &#125;&#125; 只对IE9/10有效</div><div class="line">@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;body &#123; background: orange; &#125;&#125; 只对IE10有效</div></pre></td></tr></table></figure>
</li>
<li><p>IE条件注释法(即HTML条件注释Hack)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries --&gt;</div><div class="line">&lt;!--[if lt IE 9]&gt;</div><div class="line">  &lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>我们可以通过以下网站查询CSS属性的兼容和 Hack 的写法<br><a href="http://caniuse.com/" target="_blank" rel="external">caniuse</a><br><a href="http://browserhacks.com/" target="_blank" rel="external">browserhacks</a></p>
<h4 id="常见的兼容工具"><a href="#常见的兼容工具" class="headerlink" title="常见的兼容工具"></a>常见的兼容工具</h4><h5 id="html5shiv-js"><a href="#html5shiv-js" class="headerlink" title="html5shiv.js"></a>html5shiv.js</h5><p>HTML5已经成为主流，但是还是有很多人在使用IE6等版本，这些版本并不支持HTML5的标签，这时我们就可以使用html5shiv.js来让那些不认识HTML5标签的浏览器识别元素。html5shiv.js的基本原理是:使用createElement方法，这包含document.createElement和document.createDocumentFragment，对当前页面的HTML5元素进行动态的调整，并且为这些元素提供最基本的样式。而他的使用方法也很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!--[if lt IE 9]&gt;</div><div class="line">&lt;script src=&quot;html5shiv.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;![endif]--&gt;</div><div class="line">//or</div><div class="line">&lt;!--[if lt IE 9]&gt;</div><div class="line">&lt;script src=&quot;https://cdn.bootcss.com/html5shiv/r29/html5.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure></p>
<h5 id="js能力检测"><a href="#js能力检测" class="headerlink" title="js能力检测"></a>js能力检测</h5><p>能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。采用这种方式不必顾及特定的浏览器如何如何，只要确定浏览器支持特定的能力，就可以给出解决方案。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//通过能力检测获取元素首先检测document对象是否有getElementById方法</div><div class="line">function getElement(id)&#123;</div><div class="line">    if(document.getElementById)&#123;</div><div class="line">    return document.getElementById(id);</div><div class="line">&#125;</div><div class="line">//然后检测是否有all对象</div><div class="line">else if(document.all)&#123;</div><div class="line">    return document.all[id];</div><div class="line">&#125;</div><div class="line">//如果上述都没检测到则抛出错误</div><div class="line">else&#123;</div><div class="line">    throw new Error(&apos;No way to retieve element&apos;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="respond-js"><a href="#respond-js" class="headerlink" title="respond.js"></a>respond.js</h5><p>Respond.js让不支持css3 Media Query的浏览器包括IE6-IE8等其他浏览器支持查询。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries --&gt;</div><div class="line">&lt;!--[if lt IE 9]&gt;</div><div class="line">  &lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure></p>
<h5 id="Modernizr"><a href="#Modernizr" class="headerlink" title="Modernizr"></a>Modernizr</h5><p>Modernizr让我们更加方便解决兼容性问题。</p>
<ol>
<li><p>首先在head中引入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;https://cdn.bootcss.com/modernizr/2010.07.06dev/modernizr.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>向<html>元素添加“no-js”的类</html></p>
<blockquote>
<p>当Modernizr运行的时候，它会把这个“no-js”的类变为“js”来使你知道它已经运行。Modernizr并不仅仅只做这一件事情，它还会为 所有它检测过的特性添加class类，如果浏览器不支持某个特性，它就为该特性对应的类名加上“no-”的前缀。添加no-js class到html元素下，是告诉浏览器是否支持JavaScript，如果不支持就显示no-js，如果支持就把no-js删掉。</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//在支持shadow阴影的浏览器显示shadow</div><div class="line">.boxshadow #MyContainer &#123;</div><div class="line">    border: none;</div><div class="line">    -webkit-box-shadow: #666 1px 1px 1px;</div><div class="line">    -moz-box-shadow: #666 1px 1px 1px;</div><div class="line">&#125;</div><div class="line">//不支持的浏览器显示标准的边框</div><div class="line">.no-boxshadow #MyContainer &#123;</div><div class="line">    border: 2px solid black;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="normalize-css-and-CSS-reset"><a href="#normalize-css-and-CSS-reset" class="headerlink" title="normalize.css and CSS reset"></a>normalize.css and CSS reset</h5><p>最初的CSS reset的核心作用就是清零，强制所有标签的样式进行重置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">:link,:visited &#123; text-decoration:none &#125;</div><div class="line">ul,ol &#123; list-style:none &#125;</div><div class="line">h1,h2,h3,h4,h5,h6,pre,code &#123; font-size:1em; &#125;</div><div class="line">ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,body,html,p,blockquote,</div><div class="line">fieldset,input&#123; margin:0; padding:0 &#125;</div><div class="line">a img,:link img,:visited img &#123; border:none &#125;</div><div class="line">address &#123; font-style:normal &#125;</div></pre></td></tr></table></figure></p>
<p>后来Normalize.css取代了css reset，相比之下，Normalize.css保护有用的浏览器默认样式而不是完全去掉它们，但又为为大部分HTML元素提供一般性的样式病保证浏览器的一致性。</p>
<blockquote>
<p>Normalize.css 只是一个很小的CSS文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS Reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。Normalize.css现在已经被用于Twitter Bootstrap、HTML5 Boilerplate、GOV.UK、Rdio、CSS Tricks 以及许许多多其他框架、工具和网站上。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link href=&quot;https://cdn.bootcss.com/normalize/7.0.0/normalize.min.css&quot; rel=&quot;stylesheet&quot;&gt;</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000003021766" target="_blank" rel="external">关于CSS Reset 那些事</a><br><a href="https://segmentfault.com/a/1190000003820989" target="_blank" rel="external">前端的瑞士军刀Modernizr.js</a><br><a href="https://segmentfault.com/a/1190000003923461" target="_blank" rel="external">客户端能力检测</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;有关浏览器兼容的思路和一些常用的工具。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; t
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="浏览器兼容" scheme="http://chenyixin.win/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>「专注概念 VOL.2」定位与浮动</title>
    <link href="http://chenyixin.win/2017/08/06/title-%E3%80%8C%E4%B8%93%E6%B3%A8%E6%A6%82%E5%BF%B5%20VOL.2%E3%80%8D%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/"/>
    <id>http://chenyixin.win/2017/08/06/title-「专注概念 VOL.2」定位与浮动/</id>
    <published>2017-08-06T05:40:07.138Z</published>
    <updated>2017-08-31T10:08:15.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>文章第一部分关于浮动的概念、细节以及清楚浮动的方法，第二部分关于定位的概念、细节及相关的应用方式。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>在 CSS 中我们用<code>float</code>属性来定义元素的浮动。浮动并不完全是定位的一种方式，但是它也不是正常流的布局，当元素设置为浮动后，会产生一些有意思的特征，可能会影响到布局。</p>
<h4 id="浮动的特征"><a href="#浮动的特征" class="headerlink" title="浮动的特征"></a>浮动的特征</h4><h5 id="特征之一"><a href="#特征之一" class="headerlink" title="特征之一"></a>特征之一</h5><p>浮动的元素不在文档的普通流中，文档的普通流中的布局表现上就好比浮动框不存在一样。</p>
<blockquote>
<p>普通流：浏览器根据元素在代码中出现的位置读取，再依照元素的盒子模型来呈现，具体表现为块级元素从上至下、 行内元素在每行中按从左至右的挨次排放元素。每个元素都会在HTML中占据一个位置，占用的大小和位置由盒模型来决定。</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/mw690/75fcfef2ly1fi9zh05fk1j20q00b0dfn.jpg" alt=""></p>
<p>可以看到，当我们给第一个元素设置右浮动后，由于它从文档的普通流被删除了，它不会在占据空间，下面的块元素依次上移占据空白位置。它造成的一个常见的后果就是：<strong>其容器（父）元素将得不到脱离普通流的子元素高度；即当元素设置了浮动后，它的父元素的高度会塌陷。</strong></p>
<h5 id="特征之二"><a href="#特征之二" class="headerlink" title="特征之二"></a>特征之二</h5><p>设置了浮动的元素，会向左或右浮动（没有纵向浮动）直到碰到包含框或者另一个包含框的边框为止。假如某一行没有足够的空间可供浮动元素，这个浮动元素会自动跳到下一行，直到有足够的空间为止。</p>
<p><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fia0yu1t6nj210e0dm74a.jpg" alt=""></p>
<p>可以看到，第一个例子中当我们给元素设置右浮动后，浮动元素向右移动直到其包含框的右边缘，第二个例子我们把四个盒子都设置为右浮动，直到碰到另一个浮动元素的边框为止。这个规则的意义在于：<strong>使得相同级别的浮动元素很安全，完全不用担心一个浮动元素与另一个元素相互重叠。而利用 position 定位的时候很容易出现元素相互覆盖的情况。</strong></p>
<h5 id="特征之三"><a href="#特征之三" class="headerlink" title="特征之三"></a>特征之三</h5><p>设置了浮动的元素，会将元素的<code>display</code>属性设置为 block。宽度默认为auto，也就是说浮动非替换元素，假如不指明宽度，它的宽度会尽可能的小。注意图中的 width 变化以及 display 属性。原本是行内元素的 span 在设置了浮动后，display 属性变成了block：</p>
<p><img src="https://i.loli.net/2017/08/08/5989b52ab335c.gif" alt=""></p>
<h4 id="浮动的影响"><a href="#浮动的影响" class="headerlink" title="浮动的影响"></a>浮动的影响</h4><h5 id="对父元素的影响"><a href="#对父元素的影响" class="headerlink" title="对父元素的影响"></a>对父元素的影响</h5><p>元素浮动后它脱离当前正常的文档流，所以它也无法撑开其父元素，造成父元素的塌陷。</p>
<h5 id="对子元素的影响"><a href="#对子元素的影响" class="headerlink" title="对子元素的影响"></a>对子元素的影响</h5><p>假如某个浮动元素没有设置高度和宽度，那么这个浮动元素的高度或宽度取决于子元素们的高度以及宽度的最大值（不管这个子元素浮动元素和非浮动元素都生效）。这与我们前面的特征三相一致。具体规则如图所示：</p>
<p><img src="https://i.loli.net/2017/08/08/5989b560e0039.gif" alt=""></p>
<p>这个例子恰好提供了一个解决父元素塌陷的方法，我们可以将父元素和子元素都设置为浮动，这样就可以把浮动元素包含在父元素之内，（实不实用另说）。</p>
<h5 id="对兄弟元素的影响"><a href="#对兄弟元素的影响" class="headerlink" title="对兄弟元素的影响"></a>对兄弟元素的影响</h5><p>1、浮动兄弟元素的影响</p>
<p>当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面，当空间不够时会被挤下，与特征二相吻合。</p>
<p>2、非浮动兄弟元素的影响</p>
<p>如果如果兄弟元素为内联元素，则元素会环绕浮动元素排列。<br>如果兄弟元素为块级元素，该元素占据它的位置，并且元素会处在浮动元素的下层（并且无法通过z-index属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/75fcfef2ly1fia2m1j0hmj20s709ygma.jpg" alt=""></p>
<h4 id="清楚浮动的方法"><a href="#清楚浮动的方法" class="headerlink" title="清楚浮动的方法"></a>清楚浮动的方法</h4><p>只介绍两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 伪元素清除浮动法</div><div class="line">.float::after &#123;</div><div class="line">    content: &quot;&quot;;</div><div class="line">    display: table;</div><div class="line">    clear: both;</div><div class="line">&#125;</div><div class="line">//BFC清除浮动法</div><div class="line">.cleanfix &#123;</div><div class="line">    overflow: hidden;</div><div class="line">    zoom: 1;</div><div class="line">&#125;</div><div class="line">//以上两种方法都是给浮动元素的父容器使用</div></pre></td></tr></table></figure>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h4 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h4><p>相对定位重点在于相对。使用相对定位的元素会导致元素相对它的起点进行移动，但是普通流中仍然保持着原有的默认空间，并没有脱离普通流，只是视觉上的偏移。移动元素会导致视觉上覆盖其它框。</p>
<h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>绝对定位相对复杂。使用绝对定位的元素会相对于 <strong>最近的已定位祖先元素</strong> 去移动，如果没有已定位的祖先元素，那么它的位置相对于最初的包含块。与相对定位不同，设置为绝对定位的元素框从文档流完全删除，就好像该元素原来不存在一样，元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</p>
<p>绝对定位需要注意的细节：</p>
<ol>
<li>应用了position: absolute / relative之后，会覆盖其他非定位元素，我们可以z-index 属性来改变他们的上面层级；</li>
<li>应用了position: absolute / relative之后，尽量使用自带的 top、bottom、left、right来定位，不要使用 margin；</li>
</ol>
<h3 id="定位与浮动"><a href="#定位与浮动" class="headerlink" title="定位与浮动"></a>定位与浮动</h3><p>尽量不要定位与浮动混合使用，因为这样的方式出了问题很难去调式，不过还是有几个规则可以借用。</p>
<p>1、 规则一：相对定位和浮动可以共用，先浮动再相对定位</p>
<p><img src="http://ww1.sinaimg.cn/mw690/75fcfef2ly1fia3p4z0g5j20sq0a6gm6.jpg" alt=""></p>
<p>可以看到图中盒子1同时设定了浮动和相对定位，首先它浮动到右边的位置，再相对它原来的位置向左偏移。</p>
<p>2、 规则二：绝对定位和浮动不可以共用，浮动会失去效果</p>
<p><img src="http://ww1.sinaimg.cn/mw690/75fcfef2ly1fia3thutu1j20sm0a4q3h.jpg" alt=""></p>
<p>可以看到图中盒子1同时设定了浮动和绝对定位，我们设置它左浮动，但没有效果，它相对于它的最近定位的祖先元素定位（例子中为body）。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://book.douban.com/subject/2308234/" target="_blank" rel="external">CSS权威指南</a><br><a href="http://www.w3school.com.cn/css/css_positioning_absolute.asp" target="_blank" rel="external">w3school文档</a><br><a href="http://www.cnblogs.com/coffeedeveloper/p/3145790.html#float" target="_blank" rel="external">对CSS中的Position、Float属性的一些深入探讨</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;文章第一部分关于浮动的概念、细节以及清楚浮动的方法，第二部分关于定位的概念、细节及相关的应用方式。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="CSS" scheme="http://chenyixin.win/tags/CSS/"/>
    
      <category term="float" scheme="http://chenyixin.win/tags/float/"/>
    
      <category term="position" scheme="http://chenyixin.win/tags/position/"/>
    
  </entry>
  
  <entry>
    <title>HTML 表单需要注意的细节</title>
    <link href="http://chenyixin.win/2017/08/03/title-%20HTML%20%E8%A1%A8%E5%8D%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <id>http://chenyixin.win/2017/08/03/title- HTML 表单需要注意的细节/</id>
    <published>2017-08-03T14:10:01.929Z</published>
    <updated>2017-08-31T10:07:25.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>关于 HTML 表单的一些细节和需要注意的点。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h3><h4 id="input-标签的-name-属性"><a href="#input-标签的-name-属性" class="headerlink" title="input 标签的 name 属性"></a>input 标签的 name 属性</h4><p><code>name</code> 属性规定 input 元素的名称。<strong>只有设置了 name 属性的表单元素才能在提交表单时传递它们的值。</strong> 可以说这是一个必须添加的属性，来用于对提交到服务器后的表单数据进行标识。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/*radio 使用 name 属性来分组的，所有 name属性相同的 radio 使用时其中只有一个会被选中。*/</div><div class="line">&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot;&gt;</div><div class="line">&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot;&gt;</div></pre></td></tr></table></figure>
<h4 id="form-标签的-name-属性"><a href="#form-标签的-name-属性" class="headerlink" title="form 标签的 name 属性"></a>form 标签的 name 属性</h4><p><code>name</code> 属性规定表单的名称。</p>
<h4 id="button-标签的-name-属性"><a href="#button-标签的-name-属性" class="headerlink" title="button 标签的 name 属性"></a>button 标签的 name 属性</h4><p><code>name</code> 属性为按钮规定名称。不同的 button 元素可以共享相同的名称。这就允许我们标记带有相同名称的若干按钮，以便在表单中使用时能够提交不同的值。</p>
<h3 id="value-属性"><a href="#value-属性" class="headerlink" title="value 属性"></a>value 属性</h3><p><code>value</code> 属性为 input 元素设定值。这个相对 <code>name</code>比较复杂，对于不同的输入类型，value 属性的用法也不一样：</p>
<ul>
<li>type=”button”, “reset”, “submit” - 定义按钮上的显示的文本 一般来说是必要的。</li>
<li>type=”text”, “password”, “hidden” - 定义输入字段的初始值</li>
<li>type=”checkbox”, “radio”, “image” - 定义与输入相关联的值</li>
</ul>
<p><strong>value 属性对于 <code>&lt;input type=&quot;checkbox&quot;&gt;</code> 和 <code>&lt;input type=&quot;radio&quot;&gt;</code> 是必需的。</strong></p>
<h3 id="form-标签中需要注意的标签"><a href="#form-标签中需要注意的标签" class="headerlink" title="form 标签中需要注意的标签"></a>form 标签中需要注意的标签</h3><ol>
<li><code>action</code>属性的值是一个URL，规定当提交表单时向何处发送表单数据。</li>
<li><p><code>autocomplete</code>属性规定是否启用表单的自动完成功能，这是一个HTML5新属性。当用户开始输入时，浏览器会根据过去的值进行预测，并显示供用户选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; autocomplete=&quot;on&quot;&gt;&lt;/form&gt;</div></pre></td></tr></table></figure>
</li>
<li><p><code>method</code>属性规定表单请求的方式</p>
</li>
</ol>
<blockquote>
<p>HTTP定义了客户端与服务器之间的通信方式，POST和GET是最基本的两种。GET是向服务器发索取数据的一种请求，POST是向服务器提交数据的一种请求。</p>
<ol>
<li>形式不同：GET方法会把请求的数据附在URL链接之后，用 ? 来连接URL链接和传输的数据，参数之间通过 &amp; 相连。POST方法把提交的数据放到HTTP的包体中；</li>
<li>对数据的限制不同：GET方法通过URL链接提交所以与URL链接的长度有关，由于浏览器的限制，数据传输体积较小。POST方法理论上没有限制，与服务器的处理能力有关。</li>
<li>安全性不同。GET请求账号密码将明文出现在URL上，由于缓存或者历史纪录等原因，容易被他人窃取。POST由于无法直接读取相对安全一些。</li>
</ol>
</blockquote>
<h3 id="表单提交"><a href="#表单提交" class="headerlink" title="表单提交"></a>表单提交</h3><ol>
<li><p>input[type=submit]<br>这是我们最常用的提交方式，当我们给<code>input</code>设置[type=submit]时，输入控件会变成一个按钮，显示的文字为其value值。前面提到当我们给<code>input</code>添加 name 属性后 name 也会被提交。这种的方式的缺陷是：作为一个自闭和的标签，它的样式难以定制、不可作为其他标签的容器，所以建议不要用作表单提交按钮。</p>
</li>
<li><p>input[type=button]<br>仅仅去定义一个按钮，不会引发表单提交。</p>
</li>
<li><p>button[type=submit]<br>同样是定义按钮，但更加强大，我们可以放置内容，比如文本或图像。这是该元素与使用 input 元素创建的按钮之间的不同之处。</p>
<blockquote>
<p>button标签之间的所有内容都是按钮的内容，其中包括任何可接受的正文内容，比如文本或多媒体内容。例如，我们可以在按钮中包括一个图像和相关的文本，用它们在按钮中创建一个吸引人的标记图像。</p>
</blockquote>
</li>
</ol>
<p>因此由于<code>button</code>的可定制性，我们推荐用<code>button</code>作为交互用的按钮，来提交表单。需要注意的是 <strong><code>button</code>居然也可以设置<code>name</code>和<code>value</code>并且<code>value</code>会被作为表单数据提交给服务器。</strong></p>
<h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><p><a href="http://www.w3school.com.cn/html5/html_5_form_elements.asp" target="_blank" rel="external">w3school文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;关于 HTML 表单的一些细节和需要注意的点。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlin
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="form" scheme="http://chenyixin.win/tags/form/"/>
    
      <category term="HTML" scheme="http://chenyixin.win/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>「网页运行原理 VOL.1」域名解析</title>
    <link href="http://chenyixin.win/2017/07/26/title-%20%E3%80%8C%E7%BD%91%E9%A1%B5%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%20VOL.1%E3%80%8D%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenyixin.win/2017/07/26/title- 「网页运行原理 VOL.1」域名解析/</id>
    <published>2017-07-26T12:54:48.964Z</published>
    <updated>2017-08-31T10:04:30.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>主要记述DNS的运行原理以及DNS的解析过程。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="网页运行流程"><a href="#网页运行流程" class="headerlink" title="网页运行流程"></a>网页运行流程</h3><p>当我们在浏览器输入一个URL地址时:</p>
<ol>
<li>浏览器在域名系统服务器上找出存放网页的服务器的真实地址。</li>
<li>浏览器发送 HTTP 请求信息到服务器拷贝一份网页到客户端。这条消息，包括其他所有在客户端和服务器之间传递的数据都是通过互联网TCP/IP协议传输的。</li>
<li>服务器同意客户端的请求后，会返回一个“200 OK”信息，意味着你可以查看这个网页，然后开始将网页的文件以数据包的形式传输到浏览器。</li>
<li>浏览器将数据包聚集成完整的网页，然后呈现给你。</li>
</ol>
<h3 id="为什么需要DNS解析"><a href="#为什么需要DNS解析" class="headerlink" title="为什么需要DNS解析"></a>为什么需要DNS解析</h3><p>当我们在输入URL访问网页，我们输入的域名比如<code>www.google.com</code>并不是真正的网址。在互联网中网路之间的通讯都是基于TCP/IP协议，而TCP/IP协议基于IP地址，所以真正的网址实际上是一串难以记忆的数字IP地址，比如<code>63.245.217.105</code>。但是我们并不能记住那么多的IP地址，所以我们访问网站时更多的是在地址栏中输入域名。</p>
<p>但是对浏览器来说，并不知道域名是个什么东西，这时就需要DNS来把我们输入的域名翻译成浏览器可识别的相应的IP地址，然后再去向服务器发送请求调用网页。一言蔽之：DNS主要作用就是将主机域名转换为ip地址。</p>
<blockquote>
<p>网域名称系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>
</blockquote>
<h3 id="域名解析的相关概念"><a href="#域名解析的相关概念" class="headerlink" title="域名解析的相关概念"></a>域名解析的相关概念</h3><p>DNS 的核心是一个分层系统。在这个系统的顶部是“根服务器”，这些服务器处理有关顶级域名的信息请求。根服务器只有13个IP地址，但是我们可以在全球设立这些IP的镜像，当我们对某个根服务器发出请求时，请求会被路由到该根服务器离你最近的镜像服务器。根服务器下面一层是TLD（顶级域名）服务器，当我们想根服务器请求某个域名比如<code>www.google.com</code>，根服务器并不能找到与<code>www.google.com</code>匹配的记录，但它会找到<code>.com</code>的记录，并返回给请求者，再由请求者向负责顶级域名的服务器发送新的请求，同样的我们的顶级域名服务器并不能找到与<code>www.google.com</code>匹配的记录，但它可以找到<code>google.com</code>的记录，并返回给请求者。再向负责域名级别的名称服务器继续发送请求，此时名称服务器检查其区域文件，并发现它有与 “www.google.com” 相关联的区域文件。在此文件的内部，有一个 “www” 主机的记录。此记录说明此主机所在的 IP 地址，并向请求者返回最终答案。</p>
<h3 id="域名解析的流程"><a href="#域名解析的流程" class="headerlink" title="域名解析的流程"></a>域名解析的流程</h3><p>具体的DNS解析流程如下：</p>
<ol>
<li>浏览器缓存 – 当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；</li>
<li>系统缓存 - 从 Hosts 文件查找是否有该域名和对应 IP。当我们访问某个域名时，操作系统会首先检查本地的host文件是否有这个网址的映射地址，如果有的话就调用完成域名解析。</li>
<li>路由器缓存 – 当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；</li>
<li>ISP（互联网服务提供商） DNS 缓存 – 当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；</li>
<li>如果都没有找到，则向根域名服务器查找域名对应 IP，根服务器不知道实际托管域名的位置。然而，他们会将请求引导到处理特定请求的顶级域名的名称服务器。顶级域名服务器收到请求后查看区域文件记录，它会负责找到域名级别名称服务器的IP地址，名称服务器检查其区域文件，查找相关的IP地址，并返回最终的IP地址。</li>
</ol>
<h2 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h2><p><a href="http://www.diantansuo.com/an-introduction-to-dns" target="_blank" rel="external">什么是 DNS</a><br><a href="http://www.diantansuo.com/how-dns-work-together" target="_blank" rel="external">DNS 如何工作</a><br><a href="https://yq.aliyun.com/articles/58967?spm=5176.100244.teamconlist.7.WOFDYX#" target="_blank" rel="external">域名解析篇</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/How_the_Web_works" target="_blank" rel="external">网络是如何工作的</a><br><a href="https://www.zhihu.com/question/23042131" target="_blank" rel="external">DNS解析的过程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;主要记述DNS的运行原理以及DNS的解析过程。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlin
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="网页运行原理" scheme="http://chenyixin.win/tags/%E7%BD%91%E9%A1%B5%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    
      <category term="DNS" scheme="http://chenyixin.win/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>Git 命令中的参数问题</title>
    <link href="http://chenyixin.win/2017/07/23/title-%20Git%20%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://chenyixin.win/2017/07/23/title- Git 命令中的参数问题/</id>
    <published>2017-07-23T07:56:08.843Z</published>
    <updated>2017-08-31T10:07:17.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>有关<code>git reset</code>命令的参数以及<code>git commit -a</code>的解释</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Git-reset-命令的参数"><a href="#Git-reset-命令的参数" class="headerlink" title="Git reset 命令的参数"></a>Git reset 命令的参数</h3><p><code>git reset</code>是 Git 最常用的命令之一,主要用于版本的回退重置.它的一般写法为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git reset 参数[--soft | --mixed | --hard] 版本号[&lt;commit id&gt;]</div></pre></td></tr></table></figure></p>
<h4 id="使用-hard参数"><a href="#使用-hard参数" class="headerlink" title="使用--hard参数"></a>使用<code>--hard</code>参数</h4><p>在工作区新建文件<code>reset.html</code>,然后提交到本地的仓库,此时本地的工作区和版本库都有了这个文件,如图所示:<br><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fhttuv1abtj20s60apq48.jpg" alt="1"></p>
<p>接下来我们运行命令<code>git reset --hard HEAD^</code>,关于 <strong>HEAD</strong> 参考上篇文章<a href="http://chenyixin.win/2017/07/22/title-%20Git%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Git 基本原理和常用命令</a>.这个命令会让我们的版本回到上一个版本.如图所示:<br><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fhttv9gr04j20rp0cxgn3.jpg" alt="2"></p>
<p>此时我们清晰的看到不仅仅版本库中的<code>reset.html</code>没有了,在工作区中我们新建的<code>reset.html</code>也没有了.也就是说当我们加了参数<code>--hard</code>时会:</p>
<ul>
<li>替换指针 HEAD 的指向,例子中我们指向上一个版本.</li>
<li>替换暂存区,当我们用<code>git status</code>查看状态时会提示<code>working tree clean</code>.</li>
<li>替换工作区,替换后的工作区和被替换后的暂存区是一样的,也和HEAD指针的指向是一样的.</li>
</ul>
<p><strong>这意味着<code>--hard</code>是一个比较危险的参数,它不仅仅重置我们的版本库暂存区,连工作区的内容也会受到影响.</strong></p>
<h4 id="使用-soft参数"><a href="#使用-soft参数" class="headerlink" title="使用-soft参数"></a>使用<code>-soft</code>参数</h4><p>重复类似上面的步骤,只是这次我们吧参数换为<code>--soft</code>,我们可以清晰看到区别:<br><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fhttvildgej20rl0ertab.jpg" alt="3"></p>
<p>版本库提交的<code>soft.html</code>已经重置到上个版本没有了,但是在工作区却保留着<code>soft.html</code>,也就是说当我们加了参数<code>--soft</code>时会:</p>
<ul>
<li>替换指针 HEAD 的指向,例子中我们指向上一个版本.</li>
<li>但是工作区和暂存区没有发生改变.</li>
</ul>
<p><strong>这意味着<code>--soft</code>仅仅回退到上个版本(在这个例子中),而不改变工作区和缓存区,也意味着我们对文件的修改不满意了,可以在原有的工作区文件上继续更改.相对来说是一个比较安全的指令.</strong></p>
<h3 id="Git-commit-中的参数a"><a href="#Git-commit-中的参数a" class="headerlink" title="Git commit 中的参数a"></a>Git commit 中的参数a</h3><blockquote>
<p>commit<br>-a  Tell the command to automatically stage files that have been modified and deleted, but new files you have not told git about are not affected.</p>
</blockquote>
<p>先说结论:</p>
<ul>
<li>尽量的不要用<code>git commit -a</code>这种形式来提交文件</li>
<li>尽量使用<code>git add</code>和<code>git commit</code>的分次添加提交</li>
</ul>
<p>在修改文件,注意<strong>是在修改文件后,为什么是修改呢?这意味着这个文件已经存在在版本库中</strong>,在这个基础上我们修改文件后使用<code>git commit -am</code>,此时我们不需要使用<code>git add</code>.直接使用这个命令就可以直接提交到版本库.换句话说, 一般来说在修改文件后，需要使用git add把文件加入暂存区，这样git commit时才能把已经修改的信息加入版本库，而使用git commit -a可以不用再git add。再次注意是 <strong>在修改文件后</strong>.</p>
<p>我们来模拟这种情况,首先新建<code>test.html</code>并按正常步骤提交,现在它已经在版本库中:<br><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fhtuay3x1vj20sp0ap75q.jpg" alt=""><br>现在我们修改<code>test.html</code>,并用命令<code>git commit -am</code>提交来看看:<br><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fhtudhqqlzj20sr0a0wfw.jpg" alt=""></p>
<p>ok,好像没有什么问题.现在我们新建一个文件直接用<code>git commit -a</code>来试试:<br><img src="http://ww1.sinaimg.cn/large/75fcfef2ly1fhtuywkq77j20rx0bmabe.jpg" alt=""></p>
<p>提示:</p>
<blockquote>
<p>Untracked files:<br>        test2.html<br>nothing added to commit but untracked files present</p>
</blockquote>
<p><strong>untracted files 未追踪的文件不会被提交到仓库区</strong>,也就是说新建的文件没有被追踪所以不会被提交.为什么修改的文件可以提交而新建的文件不能被提交呢?因为修改的文件比如上面的例子我们已经<code>git add</code>过,仓库会追踪文件的变动,并可以被提交.而新建的文件只是在工作区没有被追踪是不可以被提交的.</p>
<p>简单来说:<code>git commit -am &quot;say something&quot;</code>这个命令会让 <strong>当前在暂存区里面</strong> 的文件修改保存并且 commit,而新建的文件是<code>untracted files</code>状态,没有在暂存区里被 Git 仓库所标记追踪,因此是不可以用这种方式提交的.</p>
<p>再来看这个命令的解释就一目了然了:</p>
<blockquote>
<p>commit<br>-a  Tell the command to automatically stage files that have been modified and deleted, but new files you have not told git about are not affected.</p>
</blockquote>
<p>新建的文件没有加入暂存区,没有加入暂存区没有被追踪,没有追踪的文件不会被提交到仓库区.所以,<strong>不推荐使用<code>git commit -a</code>,还是推荐先<code>git add</code>再<code>git commit</code>.</strong></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://ruby-china.org/topics/4030" target="_blank" rel="external">Git git commit -a命令困惑</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000" target="_blank" rel="external">版本回退</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;有关&lt;code&gt;git reset&lt;/code&gt;命令的参数以及&lt;code&gt;git commit -a&lt;/code&gt;的解释&lt;/p&gt;
&lt;h2 i
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="Git" scheme="http://chenyixin.win/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 基本原理和常用命令</title>
    <link href="http://chenyixin.win/2017/07/22/title-%20Git%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://chenyixin.win/2017/07/22/title- Git 基本原理和常用命令/</id>
    <published>2017-07-22T13:36:11.091Z</published>
    <updated>2017-08-31T10:06:59.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>介绍 Git 的基本原理以及一些常用的操作命令。</p>
<h2 id="Git基本原理"><a href="#Git基本原理" class="headerlink" title="Git基本原理"></a>Git基本原理</h2><h3 id="Git文件改动提交的基本原理"><a href="#Git文件改动提交的基本原理" class="headerlink" title="Git文件改动提交的基本原理"></a>Git文件改动提交的基本原理</h3><p>Git 是一种分布式的版本控制工具。它的控制系统由两个部分组成:工作区（Working Directory） 和 版本库（Repository）。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/75fcfef2ly1fhsxocsxz5j20cq06iaa8.jpg" alt="git控制系统"></p>
<p>Git 的工作流程如上图所示，首先是我们日常的 <strong>工作区</strong>，它实际持有文件。其次是 <strong>版本库</strong>，即工作区隐藏文件<code>.git</code>，记录我们文件的变动和提交。在版本库中，最重要的内容是 <strong>缓存区*(Index/stage)</strong>，它就像一个缓存区域，用来临时保存你的文件变动。最后是 <strong>HEAD</strong>，它一般指向我们最后一次提交的结果。</p>
<p>也就是说。当我们往 Git 版本库中添加文件的时候，会分成两个部分来执行，首先用<code>git add</code>把文件添加到缓存区，然后再用<code>git commit</code>提交更改，即把缓存区的文件提交到当前的分支上去。</p>
<h3 id="Git版本控制的基本原理"><a href="#Git版本控制的基本原理" class="headerlink" title="Git版本控制的基本原理"></a>Git版本控制的基本原理</h3><p>Git会记录我们的每一次提交，这样我们对文件的改动就会像时间线一样被 Git 记录下来。而 <strong>HEAD</strong> 就指向这条时间线最后一次提交的结果。因此比如说我们要回退到上一个版本就可以用命令<code>git reset --hard HEAD^</code>，但如果我们要回退到某个版本，我们就必须要只要那个版本的版本号(commit id)， Git提供了命令<code>git log</code>来供我们查找历史纪录。</p>
<p>这样我们通过<code>git log</code>来查询我们需要回退的版本号，然后利用命令<code>git reset --hard 版本号</code>来回退到我们需要的版本。</p>
<h3 id="Git分支管理的基本原理"><a href="#Git分支管理的基本原理" class="headerlink" title="Git分支管理的基本原理"></a>Git分支管理的基本原理</h3><p>上面指出 <strong>HEAD</strong> 一般指向我们的最后次的结果。那么<code>HEAD</code>本身是什么呢?通俗的来说，<code>HEAD</code>是一个指针，一般来说指向分支的最顶端，也就是我们最后一次提交的结果，但实际上它可以指向任意一个节点， Git就是利用它来追踪位置。当我们初始化一个 Git 仓库时，默认指向我们的主分支<code>master</code>。假如我们创建新的分支时，我们就可以通过命令<code>git checkout 分支名</code>切换到新的分支，这时<code>HEAD</code>指向我们新建的分支，这时对工作区的修改和提交就是针对我们新建的这个分支了，而原来<code>master</code>不会变化。当我们在新建的分支上修改满意后，再切回到主分支，然后用命令<code>git merge</code>把刚刚修改的结果合并到主分支上。这样就完成了一次分支的操作。</p>
<h2 id="常用-Git-命令"><a href="#常用-Git-命令" class="headerlink" title="常用 Git 命令"></a>常用 Git 命令</h2><h3 id="文件改动提交相关"><a href="#文件改动提交相关" class="headerlink" title="文件改动提交相关"></a>文件改动提交相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 添加指定文件或目录到缓存区</div><div class="line">$ git add file/dir</div><div class="line"></div><div class="line"># 添加加当前目录的所有文件到暂存区</div><div class="line">$ git add .     </div><div class="line"></div><div class="line"># 提交缓存区到仓库区</div><div class="line">$ git commit -m &quot;代码提交信息&quot;</div><div class="line"></div><div class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</div><div class="line">$ git commit -a</div><div class="line"></div><div class="line"># 显示有变更的文件</div><div class="line">$ git status</div><div class="line"></div><div class="line"># 提交到远程的仓库</div><div class="line">git push origin master</div></pre></td></tr></table></figure>
<h3 id="版本控制相关"><a href="#版本控制相关" class="headerlink" title="版本控制相关"></a>版本控制相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 显示当前分支的版本历史</div><div class="line">$ git log</div><div class="line">$ git log --pretty=oneline</div><div class="line"></div><div class="line"># 显示暂存区和工作区的差异</div><div class="line">$ git diff</div><div class="line"></div><div class="line"># 显示当前分支的最近几次提交</div><div class="line">$ git reflog</div><div class="line"></div><div class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</div><div class="line">$ git reset --hard &quot;版本号&quot;</div></pre></td></tr></table></figure>
<h3 id="分支管理相关"><a href="#分支管理相关" class="headerlink" title="分支管理相关"></a>分支管理相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># 列出所有本地分支</div><div class="line">$ git branch</div><div class="line"></div><div class="line"># 新建一个分支，并切换到该分支</div><div class="line">$ git checkout -b &quot;分支名&quot;</div><div class="line"></div><div class="line"># 切换到指定分支，并更新工作区</div><div class="line">$ git checkout &quot;分支名&quot;</div><div class="line"></div><div class="line"># 合并指定分支到当前分支</div><div class="line">$ git merge &quot;指定分支&quot;</div><div class="line"></div><div class="line"># 删除分支</div><div class="line">$ git branch -d &quot;分支名&quot;</div><div class="line"></div><div class="line"># 提交到远程的仓库</div><div class="line">$ git push origin &quot;分支名&quot;</div><div class="line"></div><div class="line"># 要更新你的本地仓库至最新改动</div><div class="line">$ git pull</div></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 显示当前的Git配置</div><div class="line">$ git config --list</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://rogerdudler。github。io/git-guide/index。zh。html" target="_blank" rel="external">git - 简明指南</a><br><a href="http://www。ruanyifeng。com/blog/2015/12/git-cheat-sheet。html" target="_blank" rel="external">常用 Git 命令清单</a><br><a href="https://www。liaoxuefeng。com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">git教程 -廖雪峰</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;介绍 Git 的基本原理以及一些常用的操作命令。&lt;/p&gt;
&lt;h2 id=&quot;Git基本原理&quot;&gt;&lt;a href=&quot;#Git基本原理&quot; class
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="Git" scheme="http://chenyixin.win/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux 命令行和 Vim 使用的基础操作</title>
    <link href="http://chenyixin.win/2017/07/17/title-%20Linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8C%20vim%20%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://chenyixin.win/2017/07/17/title- Linux 命令行和 vim 使用的基础操作/</id>
    <published>2017-07-17T12:00:40.668Z</published>
    <updated>2017-08-31T10:08:11.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>一些 linux 命令行和 vim 编辑器的基础操作</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="linux命令行基础操作"><a href="#linux命令行基础操作" class="headerlink" title="linux命令行基础操作"></a>linux命令行基础操作</h3><p>与 Windows 中磁盘分区的概念不同, Linux 中并没有类似C盘这样的说法,而是都以文件名来表示,所有的文件和目录都挂载在根目录「/」下面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//linux命令行</div><div class="line">$ 命令 -选项缩写 --选项 参数</div><div class="line">结果</div></pre></td></tr></table></figure></p>
<h4 id="目录相关操作"><a href="#目录相关操作" class="headerlink" title="目录相关操作"></a>目录相关操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//创建目录</div><div class="line">mkdir 目录名</div><div class="line">mkdir  -p 目录路径</div><div class="line"></div><div class="line">//其中 . 代表当前目录 .. 代表上层目录 ~ 代表当前登录用户的宿主目录 - 代表前一目录,既进入当前目录之前操作的目录</div><div class="line">cd 进入目录</div><div class="line">pwd 显示当前目录</div></pre></td></tr></table></figure>
<h4 id="文件相关操作"><a href="#文件相关操作" class="headerlink" title="文件相关操作"></a>文件相关操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//创建文件</div><div class="line">touch 文件名</div><div class="line"></div><div class="line">//删除文件</div><div class="line">rm 文件</div><div class="line">rm -r 目录名</div><div class="line">rm -i 删除文件时是否确认</div><div class="line"></div><div class="line">//复制文件</div><div class="line">cp 源文件名 目标路径</div><div class="line">cp  -r 目录 目录</div><div class="line"></div><div class="line">//移动文件</div><div class="line">mv 要移动的文件 目标路径</div></pre></td></tr></table></figure>
<h4 id="列出文件清单操作"><a href="#列出文件清单操作" class="headerlink" title="列出文件清单操作"></a>列出文件清单操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ls 文件名或目录名</div><div class="line">ls -l 列出详细信息</div><div class="line">ls -a 列出所有文件包括隐藏文件</div><div class="line">ls -R 列出所有内容包括子目录</div></pre></td></tr></table></figure>
<h3 id="vim-编辑器基础操作"><a href="#vim-编辑器基础操作" class="headerlink" title="vim 编辑器基础操作"></a>vim 编辑器基础操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//进入vim编辑器</div><div class="line">vim</div><div class="line">//进入教程</div><div class="line">vimtutor</div><div class="line">//插入文本</div><div class="line">i</div><div class="line">//保存并推出</div><div class="line">:wq</div><div class="line">//直接退出</div><div class="line">:q</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.csdn.net/lykangjia/article/details/11655887" target="_blank" rel="external">linux基本命令</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;一些 linux 命令行和 vim 编辑器的基础操作&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;header
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="linux" scheme="http://chenyixin.win/tags/linux/"/>
    
      <category term="vim" scheme="http://chenyixin.win/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>「专注概念 VOL.1」JavaScript 语法</title>
    <link href="http://chenyixin.win/2017/03/05/title-%20%E3%80%8C%E4%B8%93%E6%B3%A8%E6%A6%82%E5%BF%B5%20VOL.1%E3%80%8DJavaScript%20%E8%AF%AD%E6%B3%95/"/>
    <id>http://chenyixin.win/2017/03/05/title- 「专注概念 VOL.1」JavaScript 语法/</id>
    <published>2017-03-05T15:29:39.860Z</published>
    <updated>2017-08-31T10:04:46.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote>
<p>“Focus on concepts, not syntax”<br>“把注意力放在对概念的理解，而不是语法上”</p>
</blockquote>
<p>这是在某个网站上看到的一句话，也这是记述这个系列的笔记的原因。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>变量是对“值”的引用，使用变量等同于引用一个值，每一个变量都有一个变量名，变量可以用来保存任何值。在 JavaScript 中没有块作用域，只存在全局作用域和函数作用域。当在函数中使用<code>var</code>定义一个变量，那么这个变量就是局部变量，在函数退出后就会被销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line">    var message = &apos;hi&apos;;</div><div class="line">&#125;</div><div class="line">test();</div><div class="line">alert(message);//错误</div></pre></td></tr></table></figure>
</li>
<li><p>在同一个作用域中，一个变量只能保存一个值，如果使用<code>var</code>第二次生命且赋值，会覆盖掉前面的值。</p>
</li>
<li>JavaScript引擎的工作方式是，首先解析代码，获取所有被声明的变量，然后在一行行的执行，所以所有的变量声明语句，都会被提到代码的头部，这就叫做“变量提升”。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(a);</div><div class="line">var a = 1;//undefined</div></pre></td></tr></table></figure>
</li>
</ul>
<p>JavaScript 是一行行的运行代码，按理第一行代码后应该抛出错误，但是实际上由于变量提升的原因，浏览器并不会报错，而会显示<code>undefined</code>，表示 a 已经声明但未赋值。</p>
<ul>
<li>标识符就是用来识别一个具体对象的名称，变量名就是一种标识符。</li>
<li>我们可以使用switch语句来代替多个if…else的情况，基本结构如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">switch ( expression)&#123;</div><div class="line">    case value: statement</div><div class="line">    break;</div><div class="line">    case value: statement</div><div class="line">    break;</div><div class="line">    case value: statement</div><div class="line">    break;</div><div class="line">    ...</div><div class="line">    default:statement</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>语句中的每一个情形 case ，其基本含义如果表达式等于语句中的这个值 value，则执行后面的语句 statement。break 表示提出switch结构，而default表示，当每一种case都不符合时，执行其后面的语句。</p>
<ul>
<li>三元运算符，假如语句中condition为true则，返回expr1的值，负责返回expr2的值。<br><code>(condition) ? expr1 : expr2</code></li>
<li>javascript中可以再代码中添加标签，以便将来使用。通常用来和 break 和 continue 配合使用来跳出循环。break会立即退出循环强制执行循环后面的语句，而continue虽然也是立即退出循环，但会重循环的顶层继续执行。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>JavaScript（ES5） 中有六种数据类型。<blockquote>
<p>数值（number）：整数和小数（比如1和3.14）<br>字符串（string）：字符组成的文本（比如”Hello World”）<br>布尔值（boolean）：true（真）和false（假）两个特定值<br>undefined：表示“未定义”或不存在，即此处目前没有任何值<br>null：表示空缺，即此处应该有一个值，但目前为空<br>对象（object）：各种值组成的集合</p>
</blockquote>
</li>
</ul>
<p>在这其中，数值、字符串、布尔值被称为原始类型的值，undefined 和 null 被看作是两个特殊值。而对象是JavaScript中比较复杂的值。广义的对象包括数组、函数、甚至连原始类型的值都可以包装为对象来使用。</p>
<ul>
<li>我们通常用以下三种方法来确定一个值的类型。<blockquote>
<p>typeof运算符<br>instance of运算符<br>Object.prototype.tostring()方法</p>
</blockquote>
</li>
</ul>
<p>当我们调用<code>typeof</code>运算符时候，数值、字符串、布尔值分别返回<code>number</code> <code>string</code> <code>boolean</code> ,函数返回<code>function</code> ,undefined 返回<code>undefined</code>,其他的诸如对象，数组，null都返回<code>object</code>。<br>假如我们要具体判断是否是数组或对象，我们可以使用<code>instance of</code>。</p>
<ul>
<li>如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。<blockquote>
<p>undefined<br>null<br>false<br>0<br>NaN<br>“”或’’（空字符串）</p>
</blockquote>
</li>
</ul>
<h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><ul>
<li><p>NaN是JavaScript的一种特殊值，表示非数字（NOT A NUMBER）,主要出现在将字符串解析成数字出错的场合。NaN不等于任何值，包括它本身。我们可以使用<code>isNaN</code>来判断一个值是否是NaN，但需要注意的在使用前，最好先判断该值是不是数值，因为 <strong>如果传入其他值，会被先转成数值。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">isNaN([123]) // false</div><div class="line"></div><div class="line">//good</div><div class="line">function myIsNaN(value) &#123;</div><div class="line">  return typeof value === &apos;number&apos; &amp;&amp; isNaN(value);</div><div class="line">&#125;</div><div class="line">//or</div><div class="line">function myIsNaN(value) &#123;</div><div class="line">  return value !== value;//NaN不等于任何值</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>与数值有关的全局方法<code>parseInt()</code>和<code>parseFloat()</code>。<br>parseInt方法用于将字符串转换为整数。假如字符串的头部有空格，会被自动去除，假如要转换的不是字符串，会先转换为字符串在转换。字符串转换为整数的时候是 <strong>一个一个转换，如果遇到不能转换为数字的字符，就不再进行返回已经转好的部分</strong>，换句话说只转换字符串头部可以转换的部分。（正负号除外。）该方法接受参数，表示被转换值的进制，默认为十进制转十进制。</p>
</li>
<li><p>parseFloat方法用于将一个字符串转为浮点数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">parseInt(1.23) // 1</div><div class="line">parseFloat(1.23) // 1.23</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li>字符串可以被视为字符数组，从来调用<code>[]</code>来返回某个位置的字符。但是字符串是只读的，无法运用数组的方法来改变字符串。字符串<code>length</code>属性返回字符串的长度。</li>
<li><code>charAt()</code>方法可返回指定位置的字符。<code>charCodeAt()</code> 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。我们常常用到来验证表单输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">var inputText = document.getElementsByClassName(&apos;inputtext&apos;)[0];</div><div class="line">var tip = document.getElementById(&apos;tip&apos;);</div><div class="line">var button = document.getElementsByTagName(&apos;input&apos;)[1];</div><div class="line"></div><div class="line">//字符长度</div><div class="line">var strLength = function(str)&#123;</div><div class="line">    var len = 0;</div><div class="line">    for(var i=0;i&lt;str.length;i++)&#123;</div><div class="line">        charCode =  str.charCodeAt(i);</div><div class="line">        if(charCode &gt;= 0 &amp;&amp; charCode &lt;= 128)&#123;</div><div class="line">            len +=1;</div><div class="line">        &#125;else&#123;</div><div class="line">            len +=2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">       return len;</div><div class="line">&#125;;</div><div class="line">//验证</div><div class="line">function validate()&#123;</div><div class="line">    var content = inputText.value.trim();</div><div class="line">    if(strLength(content) === 0)&#123;</div><div class="line">        tip.innerHTML = &apos;名称不能为空！&apos;;</div><div class="line">        tip.className = &apos;on&apos;;</div><div class="line">        inputText.className += &apos; warn&apos;;</div><div class="line">    &#125;else if( strLength(content)&gt;=4 &amp;&amp; strLength(content)&lt;=16 )&#123;</div><div class="line">        tip.innerHTML = &apos;格式正确&apos;;</div><div class="line">    &#125;else&#123;</div><div class="line">        tip.innerHTML =&apos;字符数应为4-16位&apos;;</div><div class="line">        tip.className = &apos;on&apos;;</div><div class="line">        inputText.className=&apos;warn&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//绑定</div><div class="line">button.onclick =function()&#123;</div><div class="line">    validate();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul>
<li><p>对象，就是一种无序的数据集合，由若干和“键值对”构成，所有键名都是字符串。我们可以用下面三种方法来生成对象。</p>
<blockquote>
<p>var object1 = {};<br>var object2 = new Object();<br>var object3 = Object.create(Object.prototype);</p>
</blockquote>
</li>
<li><p>对象的键名又称为属性，它的键值可以是任何值，如果一个属性的值为函数，那么这个属性称为方法，可以像函数一样调用。</p>
</li>
<li><p><strong>不同的变量名指向同一个对象，那么它们都是这个对象的引用，指向同一个内存地址，这意味着修改其中一个变量会影响到其他所有的变量</strong>，对于原始类型的值来说，是传值引用。因为是值的拷贝，所以当某个变量的值发生变化，另外一个不会受到影响，因为它们并不是指向同一个内存地址。</p>
</li>
<li><p>我们用<code>in</code>运算符来检查对象是否包含某个属性，用<code>for..in</code>来遍历对象的全部属性，因为可以遍历继承的属性，假如要只遍历对象本身的属性，需要用到<code>hasOwnPrototype</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (var key in person) &#123;</div><div class="line">  if (person.hasOwnProperty(key)) &#123;</div><div class="line">    console.log(key);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li><p>数组，按次序排列的一组值。数组本身一种特殊的对象，比如<code>in</code>和<code>for...in</code>都可以被数组使用。我们也可以使用对象的方法<code>Object.keys</code>来返回数组的键名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</div><div class="line"></div><div class="line">Object.keys(arr)</div><div class="line">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</div></pre></td></tr></table></figure>
</li>
<li><p>数组的length属性返回数组的成员数量。<strong>注意<code>length</code>是一个可写的属性</strong>，这意味着如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。将数组清空的一个有效方法，就是将length属性设为0。</p>
</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>(另写文章总结)</p>
<h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><ul>
<li>了解基本的错误类型：<blockquote>
<p>SyntaxError是解析代码时发生的语法错误<br>ReferenceError是引用一个不存在的变量时发生的错误<br>RangeError是当一个值超出有效范围时发生的错误<br>TypeError是变量或参数不是预期类型时发生的错误</p>
</blockquote>
</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="external">JavaScript 标准参考教程</a><br><a href="http://baike.baidu.com/item/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1?fr=aladdin" target="_blank" rel="external">JavaScript高级程序设计</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;“Focus on concepts, not syntax”&lt;br&gt;“把注意力放在对概念的理解，而不是语法上”&lt;
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="JavaScript" scheme="http://chenyixin.win/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 和树</title>
    <link href="http://chenyixin.win/2017/02/27/title-%20JavaScript%20%E5%92%8C%20%E6%A0%91/"/>
    <id>http://chenyixin.win/2017/02/27/title- JavaScript 和 树/</id>
    <published>2017-02-27T06:51:52.077Z</published>
    <updated>2017-08-31T10:07:59.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>百度 IFE 任务22到24的相关笔记，主要关于树的概念，遍历。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><p>树形结构是一种重要的数据结构，我们常常用树来组织信息，描述遍历的行为过程。首先是树的概念：树是一个有 n 个结点的有限集。在任意一个非空的树中有且仅有一个特定的结点称为根，当结点大于1时，各个结点可以分为互不相交的有限集合，每个集合本身又是一棵树，称为根的子树。树是具有层次结构的，我们把根结点所在层称为第一层，其孩子为第二层，以此类推，树中结点的最大层次称为树的深度。</p>
<p>而二叉树是一种特殊的树。它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分（其次序不能任意颠倒。）二叉树的性质：<br>1.在二叉树的第i层上至多有2的i-1次方个结点(i&gt;=1)。<br>2.深度为k的二叉树至多有2的k次方-1个结点，(k&gt;=1)。<br>3.对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1;</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历主要分三种：</p>
<ul>
<li>先（根）序遍历：根左右</li>
<li>中（根）序遍历：左根右</li>
<li>后（根）序遍历：左右根</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//前序</div><div class="line">function preOrderRec(node)&#123;</div><div class="line">    if(node)&#123;</div><div class="line">        divList.push(node);</div><div class="line">        preOrderRec(node.firstElementChild);</div><div class="line">        preOrderRec(node.lastElementChild);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//中序</div><div class="line">function inOrderRec(node)&#123;</div><div class="line">    if(node)&#123;</div><div class="line">        inOrderRec(node.firstElementChild);</div><div class="line">        divList.push(node);</div><div class="line">        inOrderRec(node.lastElementChild);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//后序</div><div class="line">function postOrderRec(node)&#123;</div><div class="line">    if(node)&#123;</div><div class="line">        postOrderRec(node.firstElementChild);</div><div class="line">        postOrderRec(node.lastElementChild);</div><div class="line">        divList.push(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多叉树遍历"><a href="#多叉树遍历" class="headerlink" title="多叉树遍历"></a>多叉树遍历</h3><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><blockquote>
<p>深度优先遍历，从初始访问结点出发，我们知道初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点。总结起来可以这样说：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</p>
</blockquote>
<p>具体算法表述如下：</p>
<ol>
<li>访问初始结点v，并标记结点v为已访问。</li>
<li>查找结点v的第一个邻接结点w。</li>
<li>若w存在，则继续执行4，否则算法结束。</li>
<li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</li>
<li>查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function traverseDF(node,nodeList)&#123;</div><div class="line">    if(node)&#123;</div><div class="line">        nodeList.push(node);</div><div class="line">        for(var i= 0;i&lt;node.children.length;i++)&#123;</div><div class="line">            traverseDF(node.children[i],nodeList);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><blockquote>
<p>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点。</p>
</blockquote>
<p>具体算法表述如下：</p>
<ol>
<li>访问初始结点v并标记结点v为已访问。</li>
<li>结点v入队列</li>
<li>当队列非空时，继续执行，否则算法结束。</li>
<li>出队列，取得队头结点u。</li>
<li>查找结点u的第一个邻接结点w。</li>
<li>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：<blockquote>
<p>1). 若结点w尚未被访问，则访问结点w并标记为已访问。<br>2). 结点w入队列<br>3). 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function traverseBF(node, nodeList) &#123;</div><div class="line">    if (node) &#123;</div><div class="line">        nodeList.push(node);</div><div class="line">        //nextElementSibling 返回当前元素在其父元素的子元素节点中的后一个元素节点,如果该元素已经是最后一个元素节点,则返回null,该属性是只读的.</div><div class="line">        traverseBF(node.nextElementSibling, nodeList);//回传 node的下一个元素对象</div><div class="line">        node = nodeList[BFindex++];</div><div class="line">        //ParentNode.firstElement 是一个只读属性，返回当前元素的第一个子元素节点，如果没有子元素节点，则返回null。</div><div class="line">        traverseBF(node.firstElementChild, nodeList);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这部分的IFE任务大部分都参考了别人的代码，感觉这方面有待加强，感觉除过 Javascript 的相关内容，如果对计算机的一些基本的基础的概念有个良好的把握的话对这些会更有帮助，理解起来可能更好理解。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000002685939" target="_blank" rel="external">图的理解：深度优先和广度优先遍历</a><br><a href="https://segmentfault.com/a/1190000000740261#articleHeader11" target="_blank" rel="external">js数据结构和算法（三）二叉树</a><br><a href="http://www.cnblogs.com/webFrontDev/p/3865719.html" target="_blank" rel="external">javascript实现数据结构： 树和二叉树,二叉树的遍历和基本操作</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;百度 IFE 任务22到24的相关笔记，主要关于树的概念，遍历。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;
    
    </summary>
    
      <category term="基础算法" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JavaScript" scheme="http://chenyixin.win/tags/JavaScript/"/>
    
      <category term="tree" scheme="http://chenyixin.win/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>IFE task 13-21 笔记</title>
    <link href="http://chenyixin.win/2017/02/26/title-%20IFE%20task%2013-21%20%E7%AC%94%E8%AE%B0/"/>
    <id>http://chenyixin.win/2017/02/26/title- IFE task 13-21 笔记/</id>
    <published>2017-02-26T08:13:39.646Z</published>
    <updated>2017-08-31T09:52:15.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>文章为百度前端技术学院2016年任务 13-21 的笔记，大概是 Jvascript 基础部分。总结了一些收获，记述了其中遇到的问题和困难，以及一点感想。因为内容稍微多一点，文章的结构就按照各个任务来划分。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="任务-13"><a href="#任务-13" class="headerlink" title="任务 13"></a>任务 13</h3><p>假设我们要获取某个输入域中的数值，我们可能需要<code>value</code>属性和’parseInt()’。首先，我们需要注意在HTML中<code>value</code>是<code>input</code>的设定值，对于不同的输入类型，<code>value</code>属性的用法也有区别：</p>
<blockquote>
<p>type=”button”, “reset”, “submit” - 定义按钮上的显示的文本<br>type=”text”, “password”, “hidden” - 定义输入字段的初始值<br>type=”checkbox”, “radio”, “image” - 定义与输入相关联的值</p>
</blockquote>
<p>正如任务13中一样我们要获取’id=”aqi-input”‘的value值，我们可以用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var inputValue = document.getElementById(&apos;aqi-input&apos;).value;</div></pre></td></tr></table></figure></p>
<p>这样我们就获得了<code>input</code>中的输入值，当然此时获得的是字符串。我们在用<code>parseInt()</code>来将给定的字符串解析成整数(如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。另外可以给其传入第二个参数，用于指定转换的基数)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var num = parseInt(inputValue);</div></pre></td></tr></table></figure></p>
<p>在实际应用过程中我们可能需要判断得到的值。这时我们可以用<code>isNaN</code>来判断是否是一个NaN值，具体操作中我们往往需要在前面加个<code>!</code>(非)来表示判断该值是否符合条件：if(!isNaN(num))，假如num是一个数值的话。</p>
<h3 id="任务14"><a href="#任务14" class="headerlink" title="任务14"></a>任务14</h3><p>对数据的操作是个人认为学习的难点，数据可能保存在一个数组中或对象里。所以对数组进行的操作是也需要重点的关注。比如在任务中我们需要对数组进行重排序。就需要用到<code>sort()</code>方法，’sort()’方法在适当的位置对数组的元素进行排序，并返回数组，默认的排序可能会按照字符串的Unicode，所以排序的顺序不是很稳定，方法接受一个参数，为某种顺序进行排列的函数。</p>
<blockquote>
<p>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；<br>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。<br>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</p>
</blockquote>
<p>所以我们可以这个来进行排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">aqiData.sort(function(a,b)&#123;</div><div class="line">    return b[1] - a[1];</div></pre></td></tr></table></figure></p>
<p>按照上面的写法，aqiData会按照自大到小的顺序来排列。除了<code>sort()</code>还有’reverse()’的方法反转数组来进行重排序。除了排序，有些时候我们还要对数组进行迭代，找出合适或者不合适的对象比如：</p>
<ul>
<li><p>filter()方法。filter方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3, 4, 5].filter(function (elem) &#123;</div><div class="line">  return (elem &gt; 3);</div><div class="line">&#125;)</div><div class="line">// [4, 5]</div></pre></td></tr></table></figure>
</li>
<li><p>map()方法。map方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var numbers = [1, 2, 3];</div><div class="line">numbers.map(function (n) &#123;</div><div class="line">  return n + 1;</div><div class="line">&#125;);</div><div class="line">// [2, 3, 4]</div><div class="line">numbers</div><div class="line">// [1, 2, 3]</div></pre></td></tr></table></figure>
</li>
<li><p>every()方法：对数组每一项运行给定函数，如果每一项返回true，则返回true some()方法：对数组每一项运行给定函数，如果任意一项返回true，则返回true forEach()方法：对数组每一项运行给定函数，无返回值，相当于遍历数组。<br>除过数组的操作，有关<code>document</code>节点的操作也很重要。<code>document</code>是文档的根节点，只要浏览器开始载入HTML文档，这个节点对象就存在了，可以直接调用。最常用比如查找节点的方法以及生成节点的方法。</p>
</li>
</ul>
<ol>
<li>查找节点</li>
</ol>
<ul>
<li>document.querySelector()，可以接受一个CSS选择器作为参数，返回匹配改选择器的元素节点，如果有多个满足条件的元素节点，则返回第一个匹配的节点。</li>
<li>document.getElementsByTagName()，返回所有指定的HTML标签的元素，返回值是一个元素的集合。</li>
<li>document.getElementsByClassName(),返回所有CLASS符合指定条件的元素，返回值一个元素的集合。</li>
<li>document.getElementsByName()，选择拥有name属性的HTML元素.</li>
<li>document.getElementById(),返回匹配指定id属性的元素节点。</li>
</ul>
<ol>
<li>生成节点</li>
</ol>
<ul>
<li>document.createElement()，用来生成网页元素节点。</li>
<li>document.createTextNode()，方法用来生成文本节点，参数为所要生成的文本节点的内容。</li>
</ul>
<p>除了作为根节点的<code>document</code>，DOM 文本对象模型中的每个组成单位都可以看作成为一个节点(node),所有节点对象都是浏览器内置的Node对象的实例，继承了Node属性和方法。比如：</p>
<ol>
<li>节点的相关属性</li>
</ol>
<ul>
<li>Node.parentNode，属性返回当前节点的父节点。</li>
<li>Node.childNodes，返回一个NodeList集合，成员包括当前节点的所有子节点。</li>
<li>Node.firstChild，Node.lastChild，firstChild属性返回当前节点的第一个子节点，lastChild属性返回当前节点的最后一个子节点。</li>
</ul>
<ol>
<li>节点对象的方法</li>
</ol>
<ul>
<li><p>Node.appendChild()方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var p = document.createElement(&apos;p&apos;);</div><div class="line">document.body.appendChild(p);</div></pre></td></tr></table></figure>
</li>
<li><p>Node.removeChild()方法接受一个 <strong>子节点</strong> 作为参数，用于从当前节点移除该子节点。<strong>它返回被移除的子节点。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var divA = document.getElementById(&apos;A&apos;);</div><div class="line">divA.parentNode.removeChild(divA);</div><div class="line">//注意：是在其父节点上调用，而不是被移除的节点。</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="任务15-和-任务20"><a href="#任务15-和-任务20" class="headerlink" title="任务15 和 任务20"></a>任务15 和 任务20</h3><p>当开始遇到较为复杂一点的功能，首先要做的就是理清逻辑，比如任务15我们需要：得到数据；对数据排序；对数据渲染；给按钮绑定函数；初始化。<br>在处理数据时我们常常对字符串进行操作，主要有这些属性和方法：</p>
<ul>
<li>length属性，返回字符串的长度。</li>
<li>concat()方法，用于合并两个字符串，返回一个新的字符串，不改变原字符串。</li>
<li>slice()方法，用于从原字符串中取出子字符串，接受两个参数，一个是起始位置，一个结束位置(不含该位置)，这个方法不会改变原字符串。</li>
<li>substr()方法，用于从原字符串中取出子字符串，接受两个参数，一个是起始位置，一个是子字符串的长度，不改变原字符串。</li>
<li>trim()方法，用于去除字符串 <strong>两端</strong> 的空格，返回一个新的字符串。</li>
<li>match()方法，用于确定原字符串是否匹配某个字符串，如果有则返回一个数组，成员为匹配的第一个字符串。可接受正则表达式。</li>
<li>replace()方法，用于替换匹配的字符串。</li>
<li>split()方法，按照给定的规则来分割字符串，返回一个有分割出来的子字符串组成的数组。</li>
</ul>
<h3 id="任务16-和-任务18"><a href="#任务16-和-任务18" class="headerlink" title="任务16 和 任务18"></a>任务16 和 任务18</h3><p>除了字符串，也常常要对Array对象进行操作。最常用的有：</p>
<ul>
<li>toString()方法返回数组的字符串形式。</li>
<li>push()方法用于在数组的末端添加一个或者多个元素，并且返回 <strong>添加新元素后的数组长度</strong>，这个方法会改变原数组。</li>
<li>pop()方法用于删除数组的最后一个元素，并且 <strong>返回该元素</strong>，这个方法会改变原数组。</li>
<li>shift()方法删除数组的第一个元素，并且 <strong>返回该元素</strong> ，这个方法会改变数组。</li>
<li>unshift()方法给数组的第一位置添加元素并且返回添加新元素的数组长度，这个方法会改变数组。</li>
<li>jion()方法以参数作为分隔符，将所有数组成员组成一个字符串返回，如果不提供参数，默认用逗号。</li>
</ul>
<p>当取得某个<code>input</code>的值后我们需要通过正则表达式来判断是否符合我们的限定，比如在任务16中，用户输入的城市名必须为中英文字符，空气质量指数必须为整数，就可以通过如下来匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function addAqiData()&#123;</div><div class="line">    var cityStr = document.getElementById(&apos;aqi-city-input&apos;).value.trim();</div><div class="line">    var numStr = document.getElementById(&apos;aqi-value-input&apos;).value.trim();</div><div class="line"></div><div class="line">    if(!cityStr.match(/^[A-Za-z\u4E00-\u9FA5]+$/))&#123;</div><div class="line">        alert(&apos;城市名称必须为汉字或英文字符！&apos;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if(!numStr.match(/^\d+$/))&#123;</div><div class="line">        alert(&apos;空气质量指数必须是整数&apos;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    aqiData[cityStr]  = numStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在任务16中我们需要为每一个项绑定删除事件。这时，我们要用到事件代理，由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var table =document.getElementById(&apos;aqi-table&apos;);</div><div class="line">table.addEventListener(&apos;click&apos;,function(event)&#123;</div><div class="line">    if(event.target &amp;&amp; event.target.nodeName === &apos;BUTTON&apos;)&#123;</div><div class="line">        delBtnHandle(event.target);</div></pre></td></tr></table></figure></p>
<p>上面代码的click事件的监听函数定义在<table>节点，但是实际上，它处理的是子节点<td>的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而且以后再添加子节点，监听函数依然有效。</td></table></p>
<h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><p><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="external">JavaScript 标准参考教程（alpha）</a><br><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">MDN javascript</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;文章为百度前端技术学院2016年任务 13-21 的笔记，大概是 Jvascript 基础部分。总结了一些收获，记述了其中遇到的问题和困难，
    
    </summary>
    
      <category term="IFE task" scheme="http://chenyixin.win/categories/IFE-task/"/>
    
    
      <category term="JavaScript" scheme="http://chenyixin.win/tags/JavaScript/"/>
    
      <category term="IFE" scheme="http://chenyixin.win/tags/IFE/"/>
    
  </entry>
  
  <entry>
    <title>利用 jQuery 实现一个清单列表小应用</title>
    <link href="http://chenyixin.win/2017/02/23/title-%20%E4%BD%BF%E7%94%A8%20jQuery%20%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95%E5%B0%8F%E5%BA%94%E7%94%A8%20/"/>
    <id>http://chenyixin.win/2017/02/23/title- 使用 jQuery 实现一个任务清单小应用 /</id>
    <published>2017-02-23T10:13:30.967Z</published>
    <updated>2017-08-31T10:05:52.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>利用 jQuery 做了一个任务清单的网页小应用，实现了其中的一些基本功能。进一步熟悉了 jQuery 的一些基本的操作和方法。第一次使用了 local storage，不过使用了相关的库Store.js。对本地存储的数据保存方式以及JSON还得再抽个时间学一下，算是知其然不知其所以然。遇到了不小的困难，主要存在于下面两个方面：数据的存储和基本概念的理解。意外的收获是学会了利用console.log的检查代码bug。这篇文章主要记述过程和思路，以及一些写代码过程中的反思。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="http://ohqryljkl.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170223144241.png" alt="脑图"></p>
<h3 id="困难与反思"><a href="#困难与反思" class="headerlink" title="困难与反思"></a>困难与反思</h3><p>假如我在写这篇文章之前先画出一个脑图整理思路的话 (上面这个图是后面整理的 )，我想遇到的问题可能会少很多。假如一上来对要实现的功能的逻辑没有清晰的思路，我发现时间大多数都用来修复函数调用等等所出现的 bug 上面了。而且，假如逻辑清晰，思路很明了的话修复bug的也会变的很快。我想下次再写，一定先要把逻辑搞清楚。比如要实现其中的提交Task功能。</p>
<ul>
<li>首先我们需要监听提交按钮，是否输入了内容</li>
<li>假如没有或为空则返回，否则</li>
<li>将输入的值推入 Task 列表</li>
<li>然后更新数据</li>
<li>渲染 Task 列表</li>
<li>在渲染的过程中用循环去遍历每个Task</li>
<li>判断单个Task是否已经完成</li>
<li>已完成的渲染已完成的CSS样式</li>
<li>未完成的渲染未完成的结构和样式</li>
<li>监听其他操作</li>
</ul>
<p>有个清晰的逻辑我们就可以利用Jquery来去实现这个功能了。</p>
<ul>
<li>我们需要监听提交按钮，我们可以用jquery 的<code>.on()</code>来添加点击事件，将点击触发的函数可以单独来写</li>
<li>我们可以利用<code>.find()</code>来查找input按钮，将val()得到的值复制给变量</li>
<li>将新得到的Task利用<code>.push()</code>给需要渲染的任务列表</li>
<li>写一个刷新数据的函数，将Task列表传入随后再调用我们的渲染函数</li>
<li>渲染函数中我们利用<code>for</code>循环来首先判断每个Task的状态分别来渲染</li>
<li>将渲染好的内容利用<code>prepend</code>或者<code>append</code>结构中区</li>
<li>监听其他事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">//部分代码，点击 [TODO](https://github.com/CChenYixin/JavaScript_demo/tree/master/demo_MY%20TODO) 访问完整代码。</div><div class="line"></div><div class="line"></div><div class="line">$form_add_task.on(&apos;submit&apos;,on_add_task_form_submit);</div><div class="line"></div><div class="line">//监听提交按钮并添加事件</div><div class="line">function on_add_task_form_submit(e)&#123;</div><div class="line">    var new_task=&#123;&#125;,$input;</div><div class="line">    //禁用默认行为</div><div class="line">    e.preventDefault();</div><div class="line">    //获取新task的值</div><div class="line">    $input = $(this).find(&apos;input[name=content]&apos;);</div><div class="line">    new_task.content =  $input.val();</div><div class="line">    //如果新task的值为空则返回，否则继续执行</div><div class="line">    if(!new_task.content) return;</div><div class="line">    // 存入新task</div><div class="line">    task_list.push(new_task);</div><div class="line">    if(add_task(new_task))&#123;</div><div class="line">        // render_task_list();</div><div class="line">        $input.val(null);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//添加task</div><div class="line">function add_task(new_task)&#123;</div><div class="line">    //更新localstrage</div><div class="line">    refresh_task_list();</div><div class="line">    // console.log(&apos;task_list&apos;,task_list);</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//更新localstroage并刷新</div><div class="line">function refresh_task_list () &#123;</div><div class="line">      store.set(&apos;task_list&apos;, task_list);</div><div class="line">      render_task_list();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">//渲染task列表</div><div class="line">function render_task_list()&#123;</div><div class="line">  // console.log(&apos;1&apos;,1);</div><div class="line">  // console.log(&apos;task_list&apos;,task_list);</div><div class="line">  var $task_list=$(&apos;.task-list&apos;);</div><div class="line">  $task_list.html(&apos;&apos;);</div><div class="line">  var complete_items =[];</div><div class="line"></div><div class="line">  for(var i = 0;i&lt;task_list.length;i++)&#123;</div><div class="line">      var item = task_list[i];</div><div class="line">      if(item &amp;&amp; item.complete)&#123;</div><div class="line">          complete_items.push(item);</div><div class="line">          var $complete_task = render_task_item(item,i);</div><div class="line">          if(!$complete_task) continue;</div><div class="line">          $complete_task.addClass(&quot;completed&quot;);</div><div class="line">          $task_list.append($complete_task);</div><div class="line">      &#125;else&#123;</div><div class="line">          $task = render_task_item(item,i);</div><div class="line">          $task_list.prepend($task);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  $task_delete_trigger = $(&apos;.action.delete&apos;);</div><div class="line">  $task_detail_trigger= $(&apos;.action.detail&apos;);</div><div class="line">  $checkbox_complete = $(&apos;.complete&apos;);</div><div class="line">  listen_task_delete();</div><div class="line">  listen_task_detail();</div><div class="line">  listen_checkbox_complete();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">  function render_task_item(data,index)&#123;</div><div class="line">      if(!data||!index) return;</div><div class="line">      var list_item_item = &apos;&lt;div class=&quot;task-item&quot; data-index=&quot;&apos;+ index +&apos;&quot;&gt;&apos;+</div><div class="line">              &apos;&lt;span&gt;&lt;input class=&quot;complete&quot;&apos; + ( data.complete ? &apos;checked&apos;:&apos;&apos;) +&apos; type=&quot;checkbox&quot;&gt;&lt;/span&gt;&apos;+</div><div class="line">              &apos;&lt;span class=&quot;text-content&quot;&gt;&apos;+ data.content + &apos;&lt;/span&gt;&apos;+</div><div class="line">              &apos;&lt;span class=&quot;action delete&quot;&gt;删除&lt;/span&gt;&apos;+</div><div class="line">              &apos;&lt;span class=&quot;action detail&quot;&gt;详细&lt;/span&gt;&apos;+</div><div class="line">          &apos;&lt;/div&gt;&apos;;</div><div class="line">      return $(list_item_item);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="bug-和反思"><a href="#bug-和反思" class="headerlink" title="bug 和反思"></a>bug 和反思</h3><p>逻辑清晰的找bug也会快一点。尤其是可以利用<code>console.log()</code>的方式。除去那些依靠JShint就可以排查的bug，首先我们可以先确定bug产生的大体范围，根据逻辑顺序，来打印<code>console.log()</code>;一步步的来测试就可以精准的确定bug产生的原因。不过暂时不知道那些动辄上万行代码是如何debug的，查找资料的时候发现chrome自带断点测试，也要抽时间来学习一下。</p>
<h3 id="npm的使用"><a href="#npm的使用" class="headerlink" title="npm的使用"></a>npm的使用</h3><p>npm 是 Node 的模块管理器，功能极其强大。我们根据一行命令，就能安装别人写好的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install &lt;packageName&gt;</div><div class="line">//卸载</div><div class="line">$ npm uninstall express</div></pre></td></tr></table></figure>
<p>模块的安装过程如下：</p>
<ul>
<li>发出npm install命令</li>
<li>npm 向 registry 查询模块压缩包的网址</li>
<li>下载压缩包，存放在~/.npm目录</li>
<li>解压压缩包到当前项目的node_modules目录</li>
</ul>
<p>我们可以在安装的时候加上<code>--save-dev</code>：</p>
<blockquote>
<p>当你为你的模块安装一个依赖模块时，正常情况下你得先安装他们（在模块根目录下npm install module-name），然后连同版本号手动将他们添加到模块配置文件package.json中的依赖里（dependencies）。<br>-save和save-dev可以省掉你手动修改package.json文件的步骤。<br>spm install module-name -save 自动把模块和版本号添加到dependencies部分<br>spm install module-name -save-dve 自动把模块和版本号添加到devdependencies部分</p>
</blockquote>
<p>在使用npm感觉很方便，另外想到的还是必须要学习git，虽然再学习初期为了节省时间用了github的客户端来上传代码，但是最终用的还是git，而且用git会更加节省时间。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>写代码前有一个清晰的逻辑。</li>
<li>基础概念的掌握和理解是最重要的没有之一。</li>
<li>要抽时间深度掌握 git,JSON,以及是改学学后端的一些知识了，至少要熟悉借口之类的。</li>
</ul>
<p>感觉最近的学习有点懈怠了，要加油。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;利用 jQuery 做了一个任务清单的网页小应用，实现了其中的一些基本功能。进一步熟悉了 jQuery 的一些基本的操作和方法。第一次使用了
    
    </summary>
    
      <category term="框架相关" scheme="http://chenyixin.win/categories/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="jQuery" scheme="http://chenyixin.win/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>立即执行函数表达式 IIFE</title>
    <link href="http://chenyixin.win/2017/01/18/title-%20%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%20IIFE%20/"/>
    <id>http://chenyixin.win/2017/01/18/title- 立即执行函数 IIFE /</id>
    <published>2017-01-18T12:23:09.016Z</published>
    <updated>2017-08-31T10:05:15.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>有半个月没有写文章，原因是作为一名前端新手 Javascript 中有太多太多的概念，最近大概开始对近段时间的学习一些知识的总结。本篇文章分为两个部分阐述常常会遇到和使用的立即执行函数 IIFE ，分别是立即执行函数是什么，以及为什么会使用这个函数。</p>
<h2 id="立即执行函数-IIFE-是什么？"><a href="#立即执行函数-IIFE-是什么？" class="headerlink" title="立即执行函数 IIFE 是什么？"></a>立即执行函数 IIFE 是什么？</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>类似于下面这两种形式，当我们在定义了函数之后需要立即调用时，可以通过加 () 的方式来调用函数。但是，由于<code>function</code>这个关键字即可以被当做语句，也可以当做表达式。所以为了避免解析上的歧义，JavaScript引擎规定，如果function关键字出现在行首，一律解释成语句。所以我们不能在函数定义后直接加 () 来立即调用它，而最简单的办法就是将<code>function</code>放在一个()中让引擎将其理解成一个表达式。这种可以立即调用函数的方法被称作“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称IIFE。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 函数声明</div><div class="line">function f() &#123;&#125;</div><div class="line"></div><div class="line">// 函数表达式</div><div class="line">var f = function f() &#123;&#125;</div><div class="line"></div><div class="line">// SyntaxError: Unexpected token (</div><div class="line">function()&#123; /* code */ &#125;();</div><div class="line"></div><div class="line">//IIFE</div><div class="line">(function()&#123; /* code */ &#125;());</div><div class="line">(function()&#123; /* code */ &#125;)();</div></pre></td></tr></table></figure>
<h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>首先，我们分析普通的函数声明和调用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 声明函数f1</div><div class="line">function f1() &#123;</div><div class="line">    console.log(&quot;f1&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过()来调用此函数</div><div class="line">f1();</div><div class="line"></div><div class="line">// 或者</div><div class="line">// 建立匿名函数并赋予变量f2</div><div class="line">var f2 = function() &#123;</div><div class="line">    console.log(&quot;f2&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过()来调用此函数</div><div class="line">f2();</div></pre></td></tr></table></figure></p>
<p>这两种方式都是用显示的方式声明函数，然后在函数名之后通过 () 来调用，自然而然，我们回想是不是可以类似直接调用匿名函数呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function()&#123; /* code */ &#125;();</div><div class="line">// SyntaxError: Unexpected token (</div></pre></td></tr></table></figure></p>
<p>浏览器会报错：<code>SyntaxError: Unexpected token (</code>，正如在定义部分说过，原因是由于<code>function</code>这个关键字即可以被当做语句，也可以当做表达式。JavaScript 的解释器会默认的将遇到的<code>function</code>关键字当做函数声明语句来进行解释。但是，函数声明的语句是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function name([param] [, param] [..., param]) &#123;</div><div class="line">   statements</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以在匿名函数后面直接加 ()的调用方式是用语法错误的。那么我们就需要通过将<code>function</code>放在一个()中的形式让解释器把()中的内容当作表达式去执行这样就能避免错误，其中我们最常见最常使用的方式有下面两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//方法一</div><div class="line">(function()&#123; /* code */ &#125;)();</div></pre></td></tr></table></figure>
<p>由于把函数的声明写在了()之中，所以解释器以表达式（expression）来解析其中代码而不会抛出错误，<strong>当我们直接向 () 中传入声明函数会直接返回此函数</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 如果传入字面量（literal），则返回表达式（expression）</div><div class="line">(1) // 1    </div><div class="line">(function()&#123;console.log(&quot;f&quot;);&#125;) // function () &#123;console.log(&quot;f&quot;)&#125;</div></pre></td></tr></table></figure></p>
<p>所以方法一其实就是我们调用函数的通用方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//方法二</div><div class="line">(function()&#123; /* code */ &#125;());</div></pre></td></tr></table></figure></p>
<p>方法二就更容易理解直接把()中的内容当作表达式来进行解释。和方法一在结果上没有什么区别。以上便是具体分析的过程。</p>
<h2 id="为什么使用立即执行函数表达式-IIFE？"><a href="#为什么使用立即执行函数表达式-IIFE？" class="headerlink" title="为什么使用立即执行函数表达式 IIFE？"></a>为什么使用立即执行函数表达式 IIFE？</h2><ul>
<li>传统的方法比较，定义和执行分开写</li>
<li>传统的方法直接污染全局命名空间（浏览器里的 global 对象，如 window）</li>
</ul>
<p>在JavaScript没有块作用域（block），只有函数作用域，在同时调用多个库的情况下，很容易造成对象或者变量的覆盖，而在IIFE内部会形成一个单独的作用域，可以封装一些外部无法读取的私有变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 创建一个立即调用的匿名函数表达式</div><div class="line">// return一个变量，其中这个变量里包含你要暴露的东西</div><div class="line">// 返回的这个变量将赋值给counter，而不是外面声明的function自身</div><div class="line"></div><div class="line">var counter = (function () &#123;</div><div class="line">    var i = 0;</div><div class="line"></div><div class="line">    return &#123;</div><div class="line">        get: function () &#123;</div><div class="line">            return i;</div><div class="line">        &#125;,</div><div class="line">        set: function (val) &#123;</div><div class="line">            i = val;</div><div class="line">        &#125;,</div><div class="line">        increment: function () &#123;</div><div class="line">            return ++i;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125; ());</div><div class="line"></div><div class="line">// counter是一个带有多个属性的对象，上面的代码对于属性的体现其实是方法</div><div class="line"></div><div class="line">counter.get(); // 0</div><div class="line">counter.set(3);</div><div class="line">counter.increment(); // 4</div><div class="line">counter.increment(); // 5</div><div class="line"></div><div class="line">counter.i; // undefined 因为i不是返回对象的属性</div><div class="line">i; // 引用错误: i 没有定义（因为i只存在于闭包）</div></pre></td></tr></table></figure></p>
<h2 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h2><p>要理解立即执行函数，最关键的是需要理解函数声明、函数表达式的基本概念和区别。</p>
<p>函数声明 (function 语句):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function name([param[, param[, ... param]]]) &#123;</div><div class="line">   statements</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>name：函数名；<br>param：被传入函数的参数的名称,一个函数最多可以有255个参数；<br>statements：这些语句组成了函数的函数体。</p>
<p>函数表达式 (function expression):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function [name]([param] [, param] [..., param]) &#123;</div><div class="line">   statements</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>name：函数名,<strong>可以省略,省略函数名的话,该函数就成为了匿名函数；</strong><br>param：被传入函数的参数的名称,一个函数最多可以有255个参数；<br>statements：这些语句组成了函数的函数体。</p>
<p>虽然都可以定义函数，但最大的区别在于：<br>解析器会率先读取函数声明，使其在执行任何代码之前就可以访问（也就是 函数声明提升）；<br>而函数表达式则需要解析器执行到它所在的代码行才会被解释执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function test() &#123;</div><div class="line">    foo();</div><div class="line"></div><div class="line">    function foo() &#123;</div><div class="line">        alert(&quot;我是会出现的啦……&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">test();</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function test() &#123;</div><div class="line">    foo();</div><div class="line"></div><div class="line">    var foo = function() &#123;</div><div class="line">        alert(&quot;我不会出现的哦……&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">test();</div><div class="line">`</div></pre></td></tr></table></figure>
<p>在上面的第一个例子中foo()是一个声明，函数声明会被提升，函数声明会连通命名和函数体一起被提升至作用域顶部，在执行 foo() 之前，作用域就知道函数 foo 的存在了。随意例子中的 alert 会被显示出来。而在例子二中由于foo()是函数表达式， 在执行 foo() 之前，作用域只知道 foo 的命名，不知道它到底是什么，所以执行会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;TypeError: foo is not a function</div></pre></td></tr></table></figure></p>
<p>函数表达式只有命名会被提升，定义的函数体则不会。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000000327820" target="_blank" rel="external">JavaScript中的立即执行函数表达式</a><br><a href="http://javascript.ruanyifeng.com/grammar/function.html#toc24" target="_blank" rel="external">JavaScript标准教程参考 —— 阮一峰</a><br><a href="https://segmentfault.com/a/1190000003746581" target="_blank" rel="external">函数声明与定义，作用域，函数声明与表达式的区别</a><br><a href="https://segmentfault.com/a/1190000005039150" target="_blank" rel="external">深入浅出JavaScript：定义函数（函数声明&amp;函数表达式）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;有半个月没有写文章，原因是作为一名前端新手 Javascript 中有太多太多的概念，最近大概开始对近段时间的学习一些知识的总结。本篇文章分
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="JavaScript" scheme="http://chenyixin.win/tags/JavaScript/"/>
    
      <category term="IIFE" scheme="http://chenyixin.win/tags/IIFE/"/>
    
  </entry>
  
  <entry>
    <title>分别利用 JavaScript 和 CSS 实现tab选项卡切换</title>
    <link href="http://chenyixin.win/2017/01/03/title-%20%E5%88%86%E5%88%AB%E5%88%A9%E7%94%A8%20JavaScript%20%E5%92%8C%20CSS%20%E5%AE%9E%E7%8E%B0tab%E9%80%89%E9%A1%B9%E5%8D%A1%E5%88%87%E6%8D%A2/"/>
    <id>http://chenyixin.win/2017/01/03/title- 分别利用 JavaScript 和 CSS 实现tab选项卡切换/</id>
    <published>2017-01-03T12:46:08.933Z</published>
    <updated>2017-08-31T10:04:40.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>大概是一次概念整理，原本这个是慕课进阶后面的编程练习，通过这个选项卡切换的小实例理清了原本对 JavaScript 概念的一些错误认识，顺便复习了一下利用 CSS 制作tab选项卡的过程，所以大概整理了一下写成文章。另外尽管如此，这个练习后还是存在一个问题：就是关于JavaScript中的 <code>this</code> 的使用问题，尽管了解了关键字 this 总是指向调用该方法的对象，但是这较为抽象的概念在实际运用和理解中还是有点问题，暂时还没有解决，特此记录下。可以这个需要大量的练习才可能摸清<code>this</code>的真正概念和使用方法吧。<strong>17年1月18号更新：文章写于刚开始学习JS时，文中方法二 Javascript 与 CSS 耦合是一种并不合适的写法。</strong></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="CSS-实现tab选项卡切换"><a href="#CSS-实现tab选项卡切换" class="headerlink" title="CSS 实现tab选项卡切换"></a>CSS 实现tab选项卡切换</h3><p>效果如下：</p>
<p><img src="http://ohqryljkl.bkt.clouddn.com/tab.gif" alt="效果如下"></p>
<p>HTML部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">div id=&quot;tabs&quot;&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">        &lt;li&gt;</div><div class="line">            &lt;input type=&quot;radio&quot; name=&quot;nav&quot; id=&quot;nav1&quot; checked&gt; /*核心代码*/</div><div class="line">            &lt;label for=&quot;nav1&quot;&gt;房产&lt;/label&gt;</div><div class="line">            &lt;div class=&quot;tab tab1&quot;&gt;</div><div class="line">                275万购昌平邻铁三居 总价20万买一居&lt;br/&gt;200万内购五环三居 140万安家东三环&lt;br/&gt;北京首现零首付楼盘 53万购东5环50平&lt;br/&gt;京楼盘直降5000 中信府 公园楼王现房</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/li&gt;</div><div class="line">        &lt;li&gt;</div><div class="line">            &lt;input type=&quot;radio&quot; name=&quot;nav&quot; id=&quot;nav2&quot;&gt;</div><div class="line">            &lt;label for=&quot;nav2&quot;&gt;家具&lt;/label&gt;</div><div class="line">            &lt;div class=&quot;tab tab2&quot;&gt;</div><div class="line">                40平出租屋大改造 美少女的混搭小窝&lt;br/&gt;经典清新简欧爱家 90平老房焕发新生&lt;br/&gt;新中式的酷色温情 66平撞色活泼家居&lt;br/&gt;瓷砖就像选好老婆 卫生间烟道的设计</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/li&gt;</div><div class="line">        &lt;li&gt;</div><div class="line">            &lt;input type=&quot;radio&quot; name=&quot;nav&quot; id=&quot;nav3&quot;&gt;</div><div class="line">            &lt;label for=&quot;nav3&quot;&gt;二手房&lt;/label&gt;</div><div class="line">            &lt;div class=&quot;tab tab3&quot;&gt;</div><div class="line">                通州豪华3居260万 二环稀缺2居250w甩&lt;br/&gt;西3环通透2居290万 130万2居限量抢购&lt;br/&gt;黄城根小学学区仅260万 121平70万抛!&lt;br/&gt;独家别墅280万 苏州桥2居优惠价248万</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>对于这种类似与选项卡的内容，最好利用 <code>ul</code> 和 <code>li</code> 把对应tab下的内容放在一起。在这个选项卡切换的 HTML 核心部分：首先，我们要实现点击tab实现相关内容的切换，这就需要用到<code>input</code>元素以及其相关的属性<code>name</code>，对于一组<code>input</code>单选按钮，我们需要设置它们的<code>name</code>为相同的值，确保当选中其中一个时，其他的不会被选中。其次，我们需要用到<code>label</code>，<code>label</code>元素不会向用户呈现任何特殊的样式。不过，它为鼠标用户改善了可用性，因为如果用户点击 label 元素内的文本，则会切换到控件本身。这样我们就可以隐藏<code>input</code>元素了，点击<code>label</code>区域就可以了，<code>label</code>标签的 for 属性应该等于<code>input</code>的 id 元素，以便将它们捆绑起来。这样HTML的核心部分基本设置好了，另外给第一个<code>input</code>设置<code>checked</code>保证其在选中状态。不然后面CSS部分<code>display</code>设置都为 none 后页面载入空空如也。</p>
<p>CSS 部分(只标注了核心部分)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&lt;style media=&quot;screen&quot;&gt;</div><div class="line">    ...</div><div class="line">    #tabs ul li .tab &#123;</div><div class="line">        display: none; /*核心代码*/</div><div class="line">        position: absolute;</div><div class="line">        width: 300px;</div><div class="line">        height: 100px;</div><div class="line">        top: 30px;</div><div class="line">        left: 0;</div><div class="line">        text-align: center;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    #tabs ul li input &#123;</div><div class="line">        display: none;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    #tabs ul li label &#123;</div><div class="line">        display: inline-block;</div><div class="line">        text-align: center;</div><div class="line">        float: left;</div><div class="line">        width: 100px;</div><div class="line">        height: 30px;</div><div class="line">        line-height: 30px;</div><div class="line">        background-color: #eee;</div><div class="line">        cursor: pointer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    #tabs ul label:hover &#123;    </div><div class="line">        background-color: #666;</div><div class="line">        color: white;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    #tabs ul li [id^=&apos;nav1&apos;]:checked~.tab1 &#123;</div><div class="line">        display: block;  /*核心代码*/</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    #tabs ul li [id^=&apos;nav2&apos;]:checked~.tab2 &#123;</div><div class="line">        display: block; /*核心代码*/</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    #tabs ul li [id^=&apos;nav3&apos;]:checked~.tab3 &#123;</div><div class="line">        display: block; /*核心代码*/</div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>我们的核心思想是：当相应 tab 的<code>label</code>被点击时候，该 tab 对应的 div 展示。为此，首先我们将tab对应的 div 部分设置为 <code>display = none;</code>  然后来实现我们的效果：点击展示。这部分我们要利用 CSS 选择器来实现。<br>首先，我们利用 <code>[attribute^=value]</code>选择器来选择相应的 <code>input</code>选择，然后使用 <code>:checked</code> （这个是必要的）选择器选择状态为选中状态的<code>input</code>元素，再利用<code>~</code>选择器，选择相应的div的类名。到此为止，利用CSS实现选项卡的切换就已经完成了，总结下核心就是利用选择器选中相应的<code>input</code>实现对应div的展现。</p>
<h3 id="JavaScript-实现tab选项卡切换"><a href="#JavaScript-实现tab选项卡切换" class="headerlink" title="JavaScript 实现tab选项卡切换"></a>JavaScript 实现tab选项卡切换</h3><h4 id="方法一：利用style语法"><a href="#方法一：利用style语法" class="headerlink" title="方法一：利用style语法"></a>方法一：利用style语法</h4><p>效果依旧：</p>
<p><img src="http://ohqryljkl.bkt.clouddn.com/tab.gif" alt="效果如下"></p>
<p>HTML部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;tabs&quot;&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">        &lt;li&gt;房产&lt;/li&gt;</div><div class="line">        &lt;li&gt;家具&lt;/li&gt;</div><div class="line">        &lt;li&gt;二手房&lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">    &lt;div class=&quot;con&quot;&gt;</div><div class="line">        &lt;div&gt;</div><div class="line">            275万购昌平邻铁三居 总价20万买一居&lt;br/&gt;200万内购五环三居 140万安家东三环&lt;br/&gt;北京首现零首付楼盘 53万购东5环50平&lt;br/&gt;京楼盘直降5000 中信府 公园楼王现房</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div&gt;</div><div class="line">            40平出租屋大改造 美少女的混搭小窝&lt;br/&gt;经典清新简欧爱家 90平老房焕发新生&lt;br/&gt;新中式的酷色温情 66平撞色活泼家居&lt;br/&gt;瓷砖就像选好老婆 卫生间烟道的设计</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div&gt;</div><div class="line">            通州豪华3居260万 二环稀缺2居250w甩&lt;br/&gt;西3环通透2居290万 130万2居限量抢购&lt;br/&gt;黄城根小学学区仅260万 121平70万抛!&lt;br/&gt;独家别墅280万 苏州桥2居优惠价248万</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>首先，上面这个部分div <code>class=&quot;con&quot;</code>这个不是必要的，只是为了练习JS额外添加的一层。HTML和CSS 部分没什么好说的，因为不需要CSS来控制，我们可以把内容div部分和tab部分分开。</p>
<p>JavaScript部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    window.onload = function() &#123;</div><div class="line">        var oTab = document.getElementById(&quot;tabs&quot;);</div><div class="line">        var oUl = oTab.getElementsByTagName(&quot;ul&quot;)[0];</div><div class="line">        var oLis = oUl.getElementsByTagName(&quot;li&quot;);</div><div class="line">        var ocon = document.getElementsByClassName(&quot;con&quot;)[0];</div><div class="line">        var oDivs = ocon.getElementsByTagName(&quot;div&quot;);</div><div class="line"></div><div class="line">        for (var i = 0, len = oLis.length; i &lt; len; i++) &#123;</div><div class="line">            oLis[i].index = i;</div><div class="line">            oLis[i].onclick = function() &#123;</div><div class="line">                for (var n = 0; n &lt; len; n++) &#123;</div><div class="line">                    oDivs[n].style.display = &quot;none&quot;;</div><div class="line">                &#125;</div><div class="line">                oDivs[this.index].style.display = &quot;block&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>我们需要的效果是选择tab标签展现相应的内容，为此我们要获得相应的li和其div；这时候我们就需要用到这一大推方法：</p>
<ul>
<li>getElementById()：返回对拥有指定 id 的第一个对象的引用。</li>
<li>getElementsByTagName()：返回带有指定标签名的对象集合。</li>
<li>getElementsByClassName()    返回包含带有指定类名的所有元素的节点列表。</li>
</ul>
<p>需要注意的是，后面两个方法返回都是一个集合，所以上面JS代码中赋值时需要注意到底是需要这个集合还是这个集合中某个元素。这也是上面这两个方法后面添加[0]的原因。接下是代码的核心部分，我们需要的效果选择相应的tab标签展现相应的内容，转化为代码就是：选择其中一个，其他的隐藏。</p>
<p>我们利用<code>for</code>循环来实现这个效果，首先我们给<code>li</code>的集合建立索引，其次在<code>for</code>循环中建立 onclick事件 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">oLis[i].onclick = function() &#123;</div><div class="line">    for (var n = 0; n &lt; len; n++) &#123;</div><div class="line">        oDivs[n].style.display = &quot;none&quot;;</div><div class="line">    &#125;</div><div class="line">    oDivs[this.index].style.display = &quot;block&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数中的循环表示：所有div的 <code>display:none;</code>,然后函数外利用关键字 this （关键字 this 总是指向调用该方法的对象）来调用相应被点击了的div，再使用<code>style</code>语法让<code>display</code>设置为<code>block</code>。</p>
<p><strong>换句话说：内层循环表示，第一次遍历li，让所有的li的dislay设置为none；内层循环结束，然后再给当前被选的li的dispaly赋值为block；</strong></p>
<h4 id="方法二：利用className-和CSS配合"><a href="#方法二：利用className-和CSS配合" class="headerlink" title="方法二：利用className 和CSS配合"></a>方法二：利用className 和CSS配合</h4><p>HTML部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;tabs&quot;&gt;</div><div class="line">     &lt;ul&gt;</div><div class="line">         &lt;li&gt;房产&lt;/li&gt;</div><div class="line">         &lt;li&gt;家具&lt;/li&gt;</div><div class="line">         &lt;li&gt;二手房&lt;/li&gt;</div><div class="line">     &lt;/ul&gt;</div><div class="line">     &lt;div class=&quot;con&quot;&gt;</div><div class="line">         &lt;div&gt;</div><div class="line">             275万购昌平邻铁三居 总价20万买一居&lt;br/&gt;200万内购五环三居 140万安家东三环&lt;br/&gt;北京首现零首付楼盘 53万购东5环50平&lt;br/&gt;京楼盘直降5000 中信府 公园楼王现房</div><div class="line">         &lt;/div&gt;</div><div class="line">         &lt;div class=&quot;hide&quot;&gt;</div><div class="line">             40平出租屋大改造 美少女的混搭小窝&lt;br/&gt;经典清新简欧爱家 90平老房焕发新生&lt;br/&gt;新中式的酷色温情 66平撞色活泼家居&lt;br/&gt;瓷砖就像选好老婆 卫生间烟道的设计</div><div class="line">         &lt;/div&gt;</div><div class="line">         &lt;div class=&quot;hide&quot;&gt;</div><div class="line">             通州豪华3居260万 二环稀缺2居250w甩&lt;br/&gt;西3环通透2居290万 130万2居限量抢购&lt;br/&gt;黄城根小学学区仅260万 121平70万抛!&lt;br/&gt;独家别墅280万 苏州桥2居优惠价248万</div><div class="line">         &lt;/div&gt;</div><div class="line">     &lt;/div&gt;</div><div class="line"> &lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>CSS部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.../*省略*/</div><div class="line">.hide &#123;</div><div class="line">    display: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>JavaScript部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    window.onload = function() &#123;</div><div class="line">        var oTab = document.getElementById(&quot;tabs&quot;);</div><div class="line">        var oUl = oTab.getElementsByTagName(&quot;ul&quot;)[0];</div><div class="line">        var oLis = oUl.getElementsByTagName(&quot;li&quot;);</div><div class="line">        var ocon = document.getElementsByClassName(&quot;con&quot;)[0];</div><div class="line">        var oDivs = ocon.getElementsByTagName(&quot;div&quot;);</div><div class="line"></div><div class="line">        for (var i = 0, len = oLis.length; i &lt; len; i++) &#123;</div><div class="line">            /*定义一个index属性对aBtn进行编号*/</div><div class="line">            oLis[i].index = i;</div><div class="line">            oLis[i].onclick = function() &#123;</div><div class="line">                for (var n = 0; n &lt; len; n++) &#123;</div><div class="line">                    /*这里是相对于未被点击的部分的样式*/</div><div class="line">                    oDivs[n].className = &quot;hide&quot;;</div><div class="line">                &#125;</div><div class="line">                	/*通过之前的index编号绑定指定的div文本*/</div><div class="line">                oDivs[this.index].className = &quot;&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>和方法一基本上类似，CSS部分首相将其他两个隐藏，然后实现用JS代码实现选择其中一个，其他的隐藏。不过在设置的部分利用的<code>className</code>属性来设置。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.w3school.com.cn/js/pro_js_object_scope.asp" target="_blank" rel="external">ECMAScript 对象作用域</a><br><a href="http://www.w3school.com.cn/js/js_htmldom_css.asp" target="_blank" rel="external"> HTML DOM - 改变 CSS</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;大概是一次概念整理，原本这个是慕课进阶后面的编程练习，通过这个选项卡切换的小实例理清了原本对 JavaScript 概念的一些错误认识，顺便
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="JavaScript" scheme="http://chenyixin.win/tags/JavaScript/"/>
    
      <category term="CSS" scheme="http://chenyixin.win/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>移动 Web 开发小记</title>
    <link href="http://chenyixin.win/2016/12/27/title-%20%E7%A7%BB%E5%8A%A8%20Web%20%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0%20/"/>
    <id>http://chenyixin.win/2016/12/27/title- 移动 Web 开发小记 /</id>
    <published>2016-12-27T14:25:33.692Z</published>
    <updated>2017-08-31T10:06:42.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>大概记述了初次接触移动 Web 页面布局实践中遇到的一些问题和值得注意的地方。具体包括了移动前端开发基本的概念，移动页面开发相关的一些<code>meta</code>标签，相对单位 rem ，与响应式图片的一些总结。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="移动前端开发的大体印象"><a href="#移动前端开发的大体印象" class="headerlink" title="移动前端开发的大体印象"></a>移动前端开发的大体印象</h3><p>移动前端开发是一个很大的概念，除了基本的前端知识外，还需要掌握一些PPI，像素，DPI等知识，对自己这种小白来说，学习过程中的一大体验就是概念多，还没有有个全局的印象首先被基础概念淹没了。所以个人感觉首先要对移动前端开发有个大体的印象。具体来说的移动前端开发包括了以下几种类型：</p>
<ul>
<li>Native App（ 原生APP ）：完全使用移动设备系统语言写成的客户端。iPhone、iPad 就是纯Object-C，安卓就是纯JAVA, 具有极强的交互性。一般静态资源都是在本地的。浏览使用方便，体验度高。</li>
<li>Web App：在移动设备的浏览器中的应用，不再是操作系统。说白了就是一个触屏版的网页，只能在浏览器中打开。资源一般都在网络上，IOS支持可以在桌面创建访问的快捷方式。</li>
<li>Hybrid App：用原生系统语言写了个容器，然后在里面运行 web 页面，资源一般在本地或者网络都可以。</li>
</ul>
<h3 id="移动前端开发中的-meta-元素"><a href="#移动前端开发中的-meta-元素" class="headerlink" title="移动前端开发中的 meta 元素"></a>移动前端开发中的 meta 元素</h3><h4 id="meta-元素"><a href="#meta-元素" class="headerlink" title="meta 元素"></a>meta 元素</h4><blockquote>
<p>标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 —— W3School</p>
</blockquote>
<h4 id="移动设备"><a href="#移动设备" class="headerlink" title="移动设备"></a>移动设备</h4><p><code>viewport</code>可以让布局在移动浏览器上显示的更好，之所有会有要用到 viewport，原因是在移动浏览器中，通常会以一个比屏幕更宽的虚拟的窗口中渲染，从而无需将页面的所有部分压缩到屏幕中（这样会把很多没有针对移动端进行优化的站点打乱）。用户可以通过平移和缩放来浏览页面的不同区域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>content 是 meta 元素中的必要属性，定义与http-equiv或name属性相关的元信息</li>
<li>name 把 content 属性关联到一个名称</li>
<li>initial-scale 为初始的缩放比例，范围从&gt;0 到10</li>
<li>minimum-scale 允许用户缩放到的最小比例</li>
<li>maximum-scale 允许用户缩放到的最大比例</li>
<li>user-scalable 用户是否可以手动缩 (no,yes)</li>
</ul>
<h3 id="相对单位-rem"><a href="#相对单位-rem" class="headerlink" title="相对单位 rem"></a>相对单位 rem</h3><p>rem（font size of the root element）是指相对于根元素的字体大小的单位。通过设置html的字体大小就可以控制rem的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">html &#123;</div><div class="line">    font-size: 62.5%;</div><div class="line">&#125;</div><div class="line">body &#123;</div><div class="line">    font-size: 1.4rem; /* 14px */</div><div class="line">&#125;</div><div class="line">h1 &#123;</div><div class="line">    font-size: 2.4rem; /* 24px */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于移动前端开发来说，我们在页面布局中有可能采用宽度百分比，高度用px固定的方式，但在某些屏幕下页面元素可能被拉长导致宽度百分比但高度没变就使得视觉上显示的不协调。要么采用响应式，但这种方式工作大，维护性难。要么采用 viewport 缩放的方式，但也有可能造成在缩放中页面糊掉的情况。这时候我们就可以采用 rem 的方式开适配。 rem不仅仅用于字体，同样也可以应用于宽高，边距等等，这样我们就可以通过设置html的字体大小就可以控制rem的大小。具体的来说，我们可以通过 JS 计算的方式去设置 font-size，因为暂时没有学习 JS ，暂时不做叙述。再者就是采用 media query 的方式来实现适配。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">html &#123;</div><div class="line">    font-size : 20px;</div><div class="line">&#125;</div><div class="line">@media only screen and (min-width: 401px)&#123;</div><div class="line">    html &#123;</div><div class="line">        font-size: 25px !important;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@media only screen and (min-width: 428px)&#123;</div><div class="line">    html &#123;</div><div class="line">        font-size: 26.75px !important;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@media only screen and (min-width: 481px)&#123;</div><div class="line">    html &#123;</div><div class="line">        font-size: 30px !important;</div><div class="line">    &#125;</div><div class="line">&#125;让</div><div class="line">@media only screen and (min-width: 569px)&#123;</div><div class="line">    html &#123;</div><div class="line">        font-size: 35px !important;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@media only screen and (min-width: 641px)&#123;</div><div class="line">    html &#123;</div><div class="line">        font-size: 40px !important;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="弹性图片"><a href="#弹性图片" class="headerlink" title="弹性图片"></a>弹性图片</h3><h4 id="max-width方式"><a href="#max-width方式" class="headerlink" title="max-width方式"></a>max-width方式</h4><p>响应式 web 设计意味着，不仅我们的布局能基于设备特征变化，内容也能。对于图片来说，对于不同的设备，需要拉伸或者收缩图片。这时候我们可以在其中加上如下 CSS 样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">img&#123;</div><div class="line">    max-width:100%;</div><div class="line">    height:auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>max-width:100%的设置，以确保图像永远不会超越其父容器的宽度。如果父容器的宽度收缩小于图像的宽度，图像将随之缩小。</li>
<li>height:auto的设置可以确保当有这种情况发生时，图像将以自身的宽高比保留。</li>
</ul>
<h4 id="picture方式"><a href="#picture方式" class="headerlink" title="picture方式"></a>picture方式</h4><p><picture>是HTML5一个新的元素。它可以通过使用 media 属性的方式来让浏览器根据当前的页面选择加载最合适的图片大小。</picture></p>
<blockquote>
<p>HTML <picture> 元素是一个容器，用来为其内部特定的 <img> 元素提供多样的 <source> 元素。浏览器会根据当前页面（即图片所在的盒子的容器）的布局以及当前浏览的设备（比如普通的屏幕和高清屏幕）去从中选择最合适的资源。</picture></p>
</blockquote>
<p>文章<a href="http://www.w3cplus.com/html5/quick-tip-how-to-use-html5-picture-for-responsive-images.html" target="_blank" rel="external">如何使用 HTML5 的picture元素处理响应式图片</a>对此有详细的论述，以下内容皆引用自原文：</p>
<p><picture>基本工作步骤如下：</picture></p>
<ul>
<li>创建<picture></picture>标签。</li>
<li>在这些标签内创建一个你想用来执行任何一个特性的<source>元素。</li>
<li>添加一个media属性，用来包含你想要的特性，如视口的当前高度(viewport height)，宽度(width)，方向(orientation)等。</li>
<li>添加一个srcset属性与相应的图像文件名相匹配，进行加载。如果你想提供不同的像素密度，例如Retina显示屏，你可以添加额外的文件名到你的srcset属性中，</li>
<li>添加一个回退的元素。</li>
<li>可以看个简单的例子，用来检查视口是否小于768px，如果小于就加载一个较小的图像：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;picture&gt;</div><div class="line">    &lt;source srcset=&quot;person_small.jpg&quot; media=&quot;(max-width: 768px)&quot;&gt;</div><div class="line">    &lt;source srcset=&quot;person_default.jpg&quot;&gt;</div><div class="line">    &lt;img srcset=&quot;person_default.jpg&quot; alt=&quot;This is King&quot;&gt;</div><div class="line">&lt;/picture&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到在屏幕&lt;=768px的时候加载的是person_small.jpg<br>当屏幕&gt;768px的时候，加载的是person_default.jpg</p>
<p>不过这是一个实验中的功能，Chrome，Firefox和Opera浏览器都已经实现了对<picture>元素的支持。在不久的将来，在其他浏览器也将得到广泛的支持。</picture></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000002407912" target="_blank" rel="external">常用meta整理</a><br><a href="http://www.css88.com/archives/5480" target="_blank" rel="external">移动前端不得不了解的html5 head 头标签</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag" target="_blank" rel="external">在移动浏览器中使用viewport元标签控制布局</a><br><a href="http://www.w3cplus.com/html5/quick-tip-how-to-use-html5-picture-for-responsive-images.html" target="_blank" rel="external">如何使用 HTML5 的picture元素处理响应式图片</a><br><a href="https://www.zhihu.com/question/20269059" target="_blank" rel="external">移动前端开发和 Web 前端开发的区别是什么？</a><br><a href="http://alloyteam.github.io/Spirit/modules/Standard/" target="_blank" rel="external">移动开发规范概述</a><br><a href="http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/" target="_blank" rel="external">移动适配利器 rem</a><br><a href="https://isux.tencent.com/web-app-rem.html" target="_blank" rel="external">web app变革之rem</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;大概记述了初次接触移动 Web 页面布局实践中遇到的一些问题和值得注意的地方。具体包括了移动前端开发基本的概念，移动页面开发相关的一些&lt;co
    
    </summary>
    
      <category term="基础概念" scheme="http://chenyixin.win/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="Mobile Web" scheme="http://chenyixin.win/tags/Mobile-Web/"/>
    
  </entry>
  
</feed>
